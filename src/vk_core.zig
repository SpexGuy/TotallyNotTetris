const std = @import("std");
const Allocator = std.mem.Allocator;

pub fn MAKE_VERSION(major: u32, minor: u32, patch: u32) u32 {
    return (@shlExact(major, u5(22)) | @shlExact(minor, u5(12))) | patch;
}

pub const API_VERSION_1_0 = MAKE_VERSION(1, 0, 0);

// Primitive Types
pub const Flags = u32;
pub const Bool32 = u32;
pub const DeviceSize = u64;
pub const SampleMask = u32;

// Opaque pointer types
pub const struct_VkInstance_T = @OpaqueType();
pub const Instance = ?*struct_VkInstance_T;
pub const struct_VkPhysicalDevice_T = @OpaqueType();
pub const PhysicalDevice = ?*struct_VkPhysicalDevice_T;
pub const struct_VkDevice_T = @OpaqueType();
pub const Device = ?*struct_VkDevice_T;
pub const struct_VkQueue_T = @OpaqueType();
pub const Queue = ?*struct_VkQueue_T;
pub const struct_VkSemaphore_T = @OpaqueType();
pub const Semaphore = ?*struct_VkSemaphore_T;
pub const struct_VkCommandBuffer_T = @OpaqueType();
pub const CommandBuffer = ?*struct_VkCommandBuffer_T;
pub const struct_VkFence_T = @OpaqueType();
pub const Fence = ?*struct_VkFence_T;
pub const struct_VkDeviceMemory_T = @OpaqueType();
pub const DeviceMemory = ?*struct_VkDeviceMemory_T;
pub const struct_VkBuffer_T = @OpaqueType();
pub const Buffer = ?*struct_VkBuffer_T;
pub const struct_VkImage_T = @OpaqueType();
pub const Image = ?*struct_VkImage_T;
pub const struct_VkEvent_T = @OpaqueType();
pub const Event = ?*struct_VkEvent_T;
pub const struct_VkQueryPool_T = @OpaqueType();
pub const QueryPool = ?*struct_VkQueryPool_T;
pub const struct_VkBufferView_T = @OpaqueType();
pub const BufferView = ?*struct_VkBufferView_T;
pub const struct_VkImageView_T = @OpaqueType();
pub const ImageView = ?*struct_VkImageView_T;
pub const struct_VkShaderModule_T = @OpaqueType();
pub const ShaderModule = ?*struct_VkShaderModule_T;
pub const struct_VkPipelineCache_T = @OpaqueType();
pub const PipelineCache = ?*struct_VkPipelineCache_T;
pub const struct_VkPipelineLayout_T = @OpaqueType();
pub const PipelineLayout = ?*struct_VkPipelineLayout_T;
pub const struct_VkRenderPass_T = @OpaqueType();
pub const RenderPass = ?*struct_VkRenderPass_T;
pub const struct_VkPipeline_T = @OpaqueType();
pub const Pipeline = ?*struct_VkPipeline_T;
pub const struct_VkDescriptorSetLayout_T = @OpaqueType();
pub const DescriptorSetLayout = ?*struct_VkDescriptorSetLayout_T;
pub const struct_VkSampler_T = @OpaqueType();
pub const Sampler = ?*struct_VkSampler_T;
pub const struct_VkDescriptorPool_T = @OpaqueType();
pub const DescriptorPool = ?*struct_VkDescriptorPool_T;
pub const struct_VkDescriptorSet_T = @OpaqueType();
pub const DescriptorSet = ?*struct_VkDescriptorSet_T;
pub const struct_VkFramebuffer_T = @OpaqueType();
pub const Framebuffer = ?*struct_VkFramebuffer_T;
pub const struct_VkCommandPool_T = @OpaqueType();
pub const CommandPool = ?*struct_VkCommandPool_T;


// -------------------------------------- Enums ----------------------------------------------

pub const Result = extern enum {
    SUCCESS = 0,
    NOT_READY = 1,
    TIMEOUT = 2,
    EVENT_SET = 3,
    EVENT_RESET = 4,
    INCOMPLETE = 5,
    ERROR_OUT_OF_HOST_MEMORY = -1,
    ERROR_OUT_OF_DEVICE_MEMORY = -2,
    ERROR_INITIALIZATION_FAILED = -3,
    ERROR_DEVICE_LOST = -4,
    ERROR_MEMORY_MAP_FAILED = -5,
    ERROR_LAYER_NOT_PRESENT = -6,
    ERROR_EXTENSION_NOT_PRESENT = -7,
    ERROR_FEATURE_NOT_PRESENT = -8,
    ERROR_INCOMPATIBLE_DRIVER = -9,
    ERROR_TOO_MANY_OBJECTS = -10,
    ERROR_FORMAT_NOT_SUPPORTED = -11,
    ERROR_FRAGMENTED_POOL = -12,
    ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    ERROR_SURFACE_LOST_KHR = -1000000000,
    ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    SUBOPTIMAL_KHR = 1000001003,
    ERROR_OUT_OF_DATE_KHR = -1000001004,
    ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    ERROR_VALIDATION_FAILED_EXT = -1000011001,
    ERROR_INVALID_SHADER_NV = -1000012000,
    ERROR_FRAGMENTATION_EXT = -1000161000,
    ERROR_NOT_PERMITTED_EXT = -1000174001,
};

pub const StructureType = extern enum {
    APPLICATION_INFO = 0,
    INSTANCE_CREATE_INFO = 1,
    DEVICE_QUEUE_CREATE_INFO = 2,
    DEVICE_CREATE_INFO = 3,
    SUBMIT_INFO = 4,
    MEMORY_ALLOCATE_INFO = 5,
    MAPPED_MEMORY_RANGE = 6,
    BIND_SPARSE_INFO = 7,
    FENCE_CREATE_INFO = 8,
    SEMAPHORE_CREATE_INFO = 9,
    EVENT_CREATE_INFO = 10,
    QUERY_POOL_CREATE_INFO = 11,
    BUFFER_CREATE_INFO = 12,
    BUFFER_VIEW_CREATE_INFO = 13,
    IMAGE_CREATE_INFO = 14,
    IMAGE_VIEW_CREATE_INFO = 15,
    SHADER_MODULE_CREATE_INFO = 16,
    PIPELINE_CACHE_CREATE_INFO = 17,
    PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    GRAPHICS_PIPELINE_CREATE_INFO = 28,
    COMPUTE_PIPELINE_CREATE_INFO = 29,
    PIPELINE_LAYOUT_CREATE_INFO = 30,
    SAMPLER_CREATE_INFO = 31,
    DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    DESCRIPTOR_POOL_CREATE_INFO = 33,
    DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    WRITE_DESCRIPTOR_SET = 35,
    COPY_DESCRIPTOR_SET = 36,
    FRAMEBUFFER_CREATE_INFO = 37,
    RENDER_PASS_CREATE_INFO = 38,
    COMMAND_POOL_CREATE_INFO = 39,
    COMMAND_BUFFER_ALLOCATE_INFO = 40,
    COMMAND_BUFFER_INHERITANCE_INFO = 41,
    COMMAND_BUFFER_BEGIN_INFO = 42,
    RENDER_PASS_BEGIN_INFO = 43,
    BUFFER_MEMORY_BARRIER = 44,
    IMAGE_MEMORY_BARRIER = 45,
    MEMORY_BARRIER = 46,
    LOADER_INSTANCE_CREATE_INFO = 47,
    LOADER_DEVICE_CREATE_INFO = 48,
    PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    BIND_BUFFER_MEMORY_INFO = 1000157000,
    BIND_IMAGE_MEMORY_INFO = 1000157001,
    PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    MEMORY_REQUIREMENTS_2 = 1000146003,
    SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    FORMAT_PROPERTIES_2 = 1000059002,
    IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000,
    PROTECTED_SUBMIT_INFO = 1000145000,
    PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    DEVICE_QUEUE_INFO_2 = 1000145003,
    SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    EXTERNAL_FENCE_PROPERTIES = 1000112001,
    EXPORT_FENCE_CREATE_INFO = 1000113000,
    EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000,
    SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    PRESENT_INFO_KHR = 1000001001,
    DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    DISPLAY_PRESENT_INFO_KHR = 1000003000,
    XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VALIDATION_FLAGS_EXT = 1000061000,
    VI_SURFACE_CREATE_INFO_NN = 1000062000,
    IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    MEMORY_FD_PROPERTIES_KHR = 1000074001,
    MEMORY_GET_FD_INFO_KHR = 1000074002,
    WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
    PRESENT_REGIONS_KHR = 1000084000,
    OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
    INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
    CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
    CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
    DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
    DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
    PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    SURFACE_CAPABILITIES_2_EXT = 1000090000,
    DISPLAY_POWER_INFO_EXT = 1000091000,
    DEVICE_EVENT_INFO_EXT = 1000091001,
    DISPLAY_EVENT_INFO_EXT = 1000091002,
    SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    HDR_METADATA_EXT = 1000105000,
    SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    FENCE_GET_FD_INFO_KHR = 1000115001,
    PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    SURFACE_CAPABILITIES_2_KHR = 1000119001,
    SURFACE_FORMAT_2_KHR = 1000119002,
    DISPLAY_PROPERTIES_2_KHR = 1000121000,
    DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    DEBUG_UTILS_LABEL_EXT = 1000128002,
    DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    EXTERNAL_FORMAT_ANDROID = 1000129005,
    PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
    SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
    SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
    PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
    PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
    DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
    DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
    IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
    PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
    //RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = 1000053000,
    //PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = 1000053001,
    //PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = 1000053002,
    //PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000,
    //PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001,
    //FORMAT_PROPERTIES_2_KHR = 1000059002,
    //IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003,
    //PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004,
    //QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005,
    //PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006,
    //SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007,
    //PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,
    //MEMORY_ALLOCATE_FLAGS_INFO_KHR = 1000060000,
    //DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = 1000060003,
    //DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = 1000060004,
    //DEVICE_GROUP_SUBMIT_INFO_KHR = 1000060005,
    //DEVICE_GROUP_BIND_SPARSE_INFO_KHR = 1000060006,
    //BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060013,
    //BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060014,
    //PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = 1000070000,
    //DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = 1000070001,
    //PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 1000071000,
    //EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 1000071001,
    //PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 1000071002,
    //EXTERNAL_BUFFER_PROPERTIES_KHR = 1000071003,
    //PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 1000071004,
    //EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 1000072000,
    //EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 1000072001,
    //EXPORT_MEMORY_ALLOCATE_INFO_KHR = 1000072002,
    //PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = 1000076000,
    //EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 1000076001,
    //EXPORT_SEMAPHORE_CREATE_INFO_KHR = 1000077000,
    //PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 1000083000,
    //DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000,
    //PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 1000112000,
    //EXTERNAL_FENCE_PROPERTIES_KHR = 1000112001,
    //EXPORT_FENCE_CREATE_INFO_KHR = 1000113000,
    //PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = 1000117000,
    //RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = 1000117001,
    //IMAGE_VIEW_USAGE_CREATE_INFO_KHR = 1000117002,
    //PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 1000117003,
    //PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = 1000120000,
    //MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000,
    //MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001,
    //BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000,
    //IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001,
    //IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002,
    //MEMORY_REQUIREMENTS_2_KHR = 1000146003,
    //SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 1000146004,
    //SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = 1000156000,
    //SAMPLER_YCBCR_CONVERSION_INFO_KHR = 1000156001,
    //BIND_IMAGE_PLANE_MEMORY_INFO_KHR = 1000156002,
    //IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = 1000156003,
    //PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 1000156004,
    //SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = 1000156005,
    //BIND_BUFFER_MEMORY_INFO_KHR = 1000157000,
    //BIND_IMAGE_MEMORY_INFO_KHR = 1000157001,
    //PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = 1000168000,
    //DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = 1000168001,
};

pub const SystemAllocationScope = extern enum {
    COMMAND = 0,
    OBJECT = 1,
    CACHE = 2,
    DEVICE = 3,
    INSTANCE = 4,
};

pub const InternalAllocationType = extern enum {
    EXECUTABLE = 0,
};

pub const Format = extern enum {
    UNDEFINED = 0,
    R4G4_UNORM_PACK8 = 1,
    R4G4B4A4_UNORM_PACK16 = 2,
    B4G4R4A4_UNORM_PACK16 = 3,
    R5G6B5_UNORM_PACK16 = 4,
    B5G6R5_UNORM_PACK16 = 5,
    R5G5B5A1_UNORM_PACK16 = 6,
    B5G5R5A1_UNORM_PACK16 = 7,
    A1R5G5B5_UNORM_PACK16 = 8,
    R8_UNORM = 9,
    R8_SNORM = 10,
    R8_USCALED = 11,
    R8_SSCALED = 12,
    R8_UINT = 13,
    R8_SINT = 14,
    R8_SRGB = 15,
    R8G8_UNORM = 16,
    R8G8_SNORM = 17,
    R8G8_USCALED = 18,
    R8G8_SSCALED = 19,
    R8G8_UINT = 20,
    R8G8_SINT = 21,
    R8G8_SRGB = 22,
    R8G8B8_UNORM = 23,
    R8G8B8_SNORM = 24,
    R8G8B8_USCALED = 25,
    R8G8B8_SSCALED = 26,
    R8G8B8_UINT = 27,
    R8G8B8_SINT = 28,
    R8G8B8_SRGB = 29,
    B8G8R8_UNORM = 30,
    B8G8R8_SNORM = 31,
    B8G8R8_USCALED = 32,
    B8G8R8_SSCALED = 33,
    B8G8R8_UINT = 34,
    B8G8R8_SINT = 35,
    B8G8R8_SRGB = 36,
    R8G8B8A8_UNORM = 37,
    R8G8B8A8_SNORM = 38,
    R8G8B8A8_USCALED = 39,
    R8G8B8A8_SSCALED = 40,
    R8G8B8A8_UINT = 41,
    R8G8B8A8_SINT = 42,
    R8G8B8A8_SRGB = 43,
    B8G8R8A8_UNORM = 44,
    B8G8R8A8_SNORM = 45,
    B8G8R8A8_USCALED = 46,
    B8G8R8A8_SSCALED = 47,
    B8G8R8A8_UINT = 48,
    B8G8R8A8_SINT = 49,
    B8G8R8A8_SRGB = 50,
    A8B8G8R8_UNORM_PACK32 = 51,
    A8B8G8R8_SNORM_PACK32 = 52,
    A8B8G8R8_USCALED_PACK32 = 53,
    A8B8G8R8_SSCALED_PACK32 = 54,
    A8B8G8R8_UINT_PACK32 = 55,
    A8B8G8R8_SINT_PACK32 = 56,
    A8B8G8R8_SRGB_PACK32 = 57,
    A2R10G10B10_UNORM_PACK32 = 58,
    A2R10G10B10_SNORM_PACK32 = 59,
    A2R10G10B10_USCALED_PACK32 = 60,
    A2R10G10B10_SSCALED_PACK32 = 61,
    A2R10G10B10_UINT_PACK32 = 62,
    A2R10G10B10_SINT_PACK32 = 63,
    A2B10G10R10_UNORM_PACK32 = 64,
    A2B10G10R10_SNORM_PACK32 = 65,
    A2B10G10R10_USCALED_PACK32 = 66,
    A2B10G10R10_SSCALED_PACK32 = 67,
    A2B10G10R10_UINT_PACK32 = 68,
    A2B10G10R10_SINT_PACK32 = 69,
    R16_UNORM = 70,
    R16_SNORM = 71,
    R16_USCALED = 72,
    R16_SSCALED = 73,
    R16_UINT = 74,
    R16_SINT = 75,
    R16_SFLOAT = 76,
    R16G16_UNORM = 77,
    R16G16_SNORM = 78,
    R16G16_USCALED = 79,
    R16G16_SSCALED = 80,
    R16G16_UINT = 81,
    R16G16_SINT = 82,
    R16G16_SFLOAT = 83,
    R16G16B16_UNORM = 84,
    R16G16B16_SNORM = 85,
    R16G16B16_USCALED = 86,
    R16G16B16_SSCALED = 87,
    R16G16B16_UINT = 88,
    R16G16B16_SINT = 89,
    R16G16B16_SFLOAT = 90,
    R16G16B16A16_UNORM = 91,
    R16G16B16A16_SNORM = 92,
    R16G16B16A16_USCALED = 93,
    R16G16B16A16_SSCALED = 94,
    R16G16B16A16_UINT = 95,
    R16G16B16A16_SINT = 96,
    R16G16B16A16_SFLOAT = 97,
    R32_UINT = 98,
    R32_SINT = 99,
    R32_SFLOAT = 100,
    R32G32_UINT = 101,
    R32G32_SINT = 102,
    R32G32_SFLOAT = 103,
    R32G32B32_UINT = 104,
    R32G32B32_SINT = 105,
    R32G32B32_SFLOAT = 106,
    R32G32B32A32_UINT = 107,
    R32G32B32A32_SINT = 108,
    R32G32B32A32_SFLOAT = 109,
    R64_UINT = 110,
    R64_SINT = 111,
    R64_SFLOAT = 112,
    R64G64_UINT = 113,
    R64G64_SINT = 114,
    R64G64_SFLOAT = 115,
    R64G64B64_UINT = 116,
    R64G64B64_SINT = 117,
    R64G64B64_SFLOAT = 118,
    R64G64B64A64_UINT = 119,
    R64G64B64A64_SINT = 120,
    R64G64B64A64_SFLOAT = 121,
    B10G11R11_UFLOAT_PACK32 = 122,
    E5B9G9R9_UFLOAT_PACK32 = 123,
    D16_UNORM = 124,
    X8_D24_UNORM_PACK32 = 125,
    D32_SFLOAT = 126,
    S8_UINT = 127,
    D16_UNORM_S8_UINT = 128,
    D24_UNORM_S8_UINT = 129,
    D32_SFLOAT_S8_UINT = 130,
    BC1_RGB_UNORM_BLOCK = 131,
    BC1_RGB_SRGB_BLOCK = 132,
    BC1_RGBA_UNORM_BLOCK = 133,
    BC1_RGBA_SRGB_BLOCK = 134,
    BC2_UNORM_BLOCK = 135,
    BC2_SRGB_BLOCK = 136,
    BC3_UNORM_BLOCK = 137,
    BC3_SRGB_BLOCK = 138,
    BC4_UNORM_BLOCK = 139,
    BC4_SNORM_BLOCK = 140,
    BC5_UNORM_BLOCK = 141,
    BC5_SNORM_BLOCK = 142,
    BC6H_UFLOAT_BLOCK = 143,
    BC6H_SFLOAT_BLOCK = 144,
    BC7_UNORM_BLOCK = 145,
    BC7_SRGB_BLOCK = 146,
    ETC2_R8G8B8_UNORM_BLOCK = 147,
    ETC2_R8G8B8_SRGB_BLOCK = 148,
    ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    EAC_R11_UNORM_BLOCK = 153,
    EAC_R11_SNORM_BLOCK = 154,
    EAC_R11G11_UNORM_BLOCK = 155,
    EAC_R11G11_SNORM_BLOCK = 156,
    ASTC_4x4_UNORM_BLOCK = 157,
    ASTC_4x4_SRGB_BLOCK = 158,
    ASTC_5x4_UNORM_BLOCK = 159,
    ASTC_5x4_SRGB_BLOCK = 160,
    ASTC_5x5_UNORM_BLOCK = 161,
    ASTC_5x5_SRGB_BLOCK = 162,
    ASTC_6x5_UNORM_BLOCK = 163,
    ASTC_6x5_SRGB_BLOCK = 164,
    ASTC_6x6_UNORM_BLOCK = 165,
    ASTC_6x6_SRGB_BLOCK = 166,
    ASTC_8x5_UNORM_BLOCK = 167,
    ASTC_8x5_SRGB_BLOCK = 168,
    ASTC_8x6_UNORM_BLOCK = 169,
    ASTC_8x6_SRGB_BLOCK = 170,
    ASTC_8x8_UNORM_BLOCK = 171,
    ASTC_8x8_SRGB_BLOCK = 172,
    ASTC_10x5_UNORM_BLOCK = 173,
    ASTC_10x5_SRGB_BLOCK = 174,
    ASTC_10x6_UNORM_BLOCK = 175,
    ASTC_10x6_SRGB_BLOCK = 176,
    ASTC_10x8_UNORM_BLOCK = 177,
    ASTC_10x8_SRGB_BLOCK = 178,
    ASTC_10x10_UNORM_BLOCK = 179,
    ASTC_10x10_SRGB_BLOCK = 180,
    ASTC_12x10_UNORM_BLOCK = 181,
    ASTC_12x10_SRGB_BLOCK = 182,
    ASTC_12x12_UNORM_BLOCK = 183,
    ASTC_12x12_SRGB_BLOCK = 184,
    G8B8G8R8_422_UNORM = 1000156000,
    B8G8R8G8_422_UNORM = 1000156001,
    G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    G8_B8R8_2PLANE_420_UNORM = 1000156003,
    G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    G8_B8R8_2PLANE_422_UNORM = 1000156005,
    G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    R10X6_UNORM_PACK16 = 1000156007,
    R10X6G10X6_UNORM_2PACK16 = 1000156008,
    R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    R12X4_UNORM_PACK16 = 1000156017,
    R12X4G12X4_UNORM_2PACK16 = 1000156018,
    R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    G16B16G16R16_422_UNORM = 1000156027,
    B16G16R16G16_422_UNORM = 1000156028,
    G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    G16_B16R16_2PLANE_420_UNORM = 1000156030,
    G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    G16_B16R16_2PLANE_422_UNORM = 1000156032,
    G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
};

pub const ImageType = extern enum {
   1D = 0,
   2D = 1,
   3D = 2,
};

pub const ImageTiling = extern enum {
    OPTIMAL = 0,
    LINEAR = 1,
};

pub const PhysicalDeviceType = extern enum {
    OTHER = 0,
    INTEGRATED_GPU = 1,
    DISCRETE_GPU = 2,
    VIRTUAL_GPU = 3,
    CPU = 4,
};

pub const QueryType = extern enum {
    OCCLUSION = 0,
    PIPELINE_STATISTICS = 1,
    TIMESTAMP = 2,
};

pub const SharingMode = extern enum {
    EXCLUSIVE = 0,
    CONCURRENT = 1,
};

pub const ImageLayout = extern enum {
    UNDEFINED = 0,
    GENERAL = 1,
    COLOR_ATTACHMENT_OPTIMAL = 2,
    DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    SHADER_READ_ONLY_OPTIMAL = 5,
    TRANSFER_SRC_OPTIMAL = 6,
    TRANSFER_DST_OPTIMAL = 7,
    PREINITIALIZED = 8,
    DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    PRESENT_SRC_KHR = 1000001002,
    SHARED_PRESENT_KHR = 1000111000,
};

pub const ImageViewType = extern enum {
    1D = 0,
    2D = 1,
    3D = 2,
    CUBE = 3,
    1D_ARRAY = 4,
    2D_ARRAY = 5,
    CUBE_ARRAY = 6,
};

pub const ComponentSwizzle = extern enum {
    IDENTITY = 0,
    ZERO = 1,
    ONE = 2,
    R = 3,
    G = 4,
    B = 5,
    A = 6,
};

pub const VertexInputRate = extern enum {
    VERTEX = 0,
    INSTANCE = 1,
};

pub const PrimitiveTopology = extern enum {
    POINT_LIST = 0,
    LINE_LIST = 1,
    LINE_STRIP = 2,
    TRIANGLE_LIST = 3,
    TRIANGLE_STRIP = 4,
    TRIANGLE_FAN = 5,
    LINE_LIST_WITH_ADJACENCY = 6,
    LINE_STRIP_WITH_ADJACENCY = 7,
    TRIANGLE_LIST_WITH_ADJACENCY = 8,
    TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    PATCH_LIST = 10,
};

pub const PolygonMode = extern enum {
    FILL = 0,
    LINE = 1,
    POINT = 2,
    FILL_RECTANGLE_NV = 1000153000,
};

pub const FrontFace = extern enum {
    COUNTER_CLOCKWISE = 0,
    CLOCKWISE = 1,
};

pub const CompareOp = extern enum {
    NEVER = 0,
    LESS = 1,
    EQUAL = 2,
    LESS_OR_EQUAL = 3,
    GREATER = 4,
    NOT_EQUAL = 5,
    GREATER_OR_EQUAL = 6,
    ALWAYS = 7,
};

pub const StencilOp = extern enum {
    KEEP = 0,
    ZERO = 1,
    REPLACE = 2,
    INCREMENT_AND_CLAMP = 3,
    DECREMENT_AND_CLAMP = 4,
    INVERT = 5,
    INCREMENT_AND_WRAP = 6,
    DECREMENT_AND_WRAP = 7,
};

pub const LogicOp = extern enum {
    CLEAR = 0,
    AND = 1,
    AND_REVERSE = 2,
    COPY = 3,
    AND_INVERTED = 4,
    NO_OP = 5,
    XOR = 6,
    OR = 7,
    NOR = 8,
    EQUIVALENT = 9,
    INVERT = 10,
    OR_REVERSE = 11,
    COPY_INVERTED = 12,
    OR_INVERTED = 13,
    NAND = 14,
    SET = 15,
};

pub const BlendFactor = extern enum {
    ZERO = 0,
    ONE = 1,
    SRC_COLOR = 2,
    ONE_MINUS_SRC_COLOR = 3,
    DST_COLOR = 4,
    ONE_MINUS_DST_COLOR = 5,
    SRC_ALPHA = 6,
    ONE_MINUS_SRC_ALPHA = 7,
    DST_ALPHA = 8,
    ONE_MINUS_DST_ALPHA = 9,
    CONSTANT_COLOR = 10,
    ONE_MINUS_CONSTANT_COLOR = 11,
    CONSTANT_ALPHA = 12,
    ONE_MINUS_CONSTANT_ALPHA = 13,
    SRC_ALPHA_SATURATE = 14,
    SRC1_COLOR = 15,
    ONE_MINUS_SRC1_COLOR = 16,
    SRC1_ALPHA = 17,
    ONE_MINUS_SRC1_ALPHA = 18,
};

pub const BlendOp = extern enum {
    ADD = 0,
    SUBTRACT = 1,
    REVERSE_SUBTRACT = 2,
    MIN = 3,
    MAX = 4,
    ZERO_EXT = 1000148000,
    SRC_EXT = 1000148001,
    DST_EXT = 1000148002,
    SRC_OVER_EXT = 1000148003,
    DST_OVER_EXT = 1000148004,
    SRC_IN_EXT = 1000148005,
    DST_IN_EXT = 1000148006,
    SRC_OUT_EXT = 1000148007,
    DST_OUT_EXT = 1000148008,
    SRC_ATOP_EXT = 1000148009,
    DST_ATOP_EXT = 1000148010,
    XOR_EXT = 1000148011,
    MULTIPLY_EXT = 1000148012,
    SCREEN_EXT = 1000148013,
    OVERLAY_EXT = 1000148014,
    DARKEN_EXT = 1000148015,
    LIGHTEN_EXT = 1000148016,
    COLORDODGE_EXT = 1000148017,
    COLORBURN_EXT = 1000148018,
    HARDLIGHT_EXT = 1000148019,
    SOFTLIGHT_EXT = 1000148020,
    DIFFERENCE_EXT = 1000148021,
    EXCLUSION_EXT = 1000148022,
    INVERT_EXT = 1000148023,
    INVERT_RGB_EXT = 1000148024,
    LINEARDODGE_EXT = 1000148025,
    LINEARBURN_EXT = 1000148026,
    VIVIDLIGHT_EXT = 1000148027,
    LINEARLIGHT_EXT = 1000148028,
    PINLIGHT_EXT = 1000148029,
    HARDMIX_EXT = 1000148030,
    HSL_HUE_EXT = 1000148031,
    HSL_SATURATION_EXT = 1000148032,
    HSL_COLOR_EXT = 1000148033,
    HSL_LUMINOSITY_EXT = 1000148034,
    PLUS_EXT = 1000148035,
    PLUS_CLAMPED_EXT = 1000148036,
    PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    PLUS_DARKER_EXT = 1000148038,
    MINUS_EXT = 1000148039,
    MINUS_CLAMPED_EXT = 1000148040,
    CONTRAST_EXT = 1000148041,
    INVERT_OVG_EXT = 1000148042,
    RED_EXT = 1000148043,
    GREEN_EXT = 1000148044,
    BLUE_EXT = 1000148045,
};

pub const DynamicState = extern enum {
    VIEWPORT = 0,
    SCISSOR = 1,
    LINE_WIDTH = 2,
    DEPTH_BIAS = 3,
    BLEND_CONSTANTS = 4,
    DEPTH_BOUNDS = 5,
    STENCIL_COMPARE_MASK = 6,
    STENCIL_WRITE_MASK = 7,
    STENCIL_REFERENCE = 8,
    VIEWPORT_W_SCALING_NV = 1000087000,
    DISCARD_RECTANGLE_EXT = 1000099000,
    SAMPLE_LOCATIONS_EXT = 1000143000,
};

pub const Filter = extern enum {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
};

pub const SamplerMipmapMode = extern enum {
    NEAREST = 0,
    LINEAR = 1,
};

pub const SamplerAddressMode = extern enum {
    REPEAT = 0,
    MIRRORED_REPEAT = 1,
    CLAMP_TO_EDGE = 2,
    CLAMP_TO_BORDER = 3,
    MIRROR_CLAMP_TO_EDGE = 4,
};

pub const BorderColor = extern enum {
    FLOAT_TRANSPARENT_BLACK = 0,
    INT_TRANSPARENT_BLACK = 1,
    FLOAT_OPAQUE_BLACK = 2,
    INT_OPAQUE_BLACK = 3,
    FLOAT_OPAQUE_WHITE = 4,
    INT_OPAQUE_WHITE = 5,
};

pub const DescriptorType = extern enum {
    SAMPLER = 0,
    COMBINED_IMAGE_SAMPLER = 1,
    SAMPLED_IMAGE = 2,
    STORAGE_IMAGE = 3,
    UNIFORM_TEXEL_BUFFER = 4,
    STORAGE_TEXEL_BUFFER = 5,
    UNIFORM_BUFFER = 6,
    STORAGE_BUFFER = 7,
    UNIFORM_BUFFER_DYNAMIC = 8,
    STORAGE_BUFFER_DYNAMIC = 9,
    INPUT_ATTACHMENT = 10,
    RANGE_SIZE = 11,
};

pub const AttachmentLoadOp = extern enum {
    LOAD = 0,
    CLEAR = 1,
    DONT_CARE = 2,
};

pub const AttachmentStoreOp = extern enum {
    STORE = 0,
    DONT_CARE = 1,
};

pub const PipelineBindPoint = extern enum {
    GRAPHICS = 0,
    COMPUTE = 1,
};

pub const CommandBufferLevel = extern enum {
    PRIMARY = 0,
    SECONDARY = 1,
};

pub const IndexType = extern enum {
    UINT16 = 0,
    UINT32 = 1,
};

pub const SubpassContents = extern enum {
    INLINE = 0,
    SECONDARY_COMMAND_BUFFERS = 1,
};

pub const ObjectType = extern enum {
    UNKNOWN = 0,
    INSTANCE = 1,
    PHYSICAL_DEVICE = 2,
    DEVICE = 3,
    QUEUE = 4,
    SEMAPHORE = 5,
    COMMAND_BUFFER = 6,
    FENCE = 7,
    DEVICE_MEMORY = 8,
    BUFFER = 9,
    IMAGE = 10,
    EVENT = 11,
    QUERY_POOL = 12,
    BUFFER_VIEW = 13,
    IMAGE_VIEW = 14,
    SHADER_MODULE = 15,
    PIPELINE_CACHE = 16,
    PIPELINE_LAYOUT = 17,
    RENDER_PASS = 18,
    PIPELINE = 19,
    DESCRIPTOR_SET_LAYOUT = 20,
    SAMPLER = 21,
    DESCRIPTOR_POOL = 22,
    DESCRIPTOR_SET = 23,
    FRAMEBUFFER = 24,
    COMMAND_POOL = 25,
    SAMPLER_YCBCR_CONVERSION = 1000156000,
    DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    SURFACE_KHR = 1000000000,
    SWAPCHAIN_KHR = 1000001000,
    DISPLAY_KHR = 1000002000,
    DISPLAY_MODE_KHR = 1000002001,
    DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    OBJECT_TABLE_NVX = 1000086000,
    INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001,
    DEBUG_UTILS_MESSENGER_EXT = 1000128000,
    VALIDATION_CACHE_EXT = 1000160000,
    DESCRIPTOR_UPDATE_TEMPLATE_KHR = 1000085000,
    SAMPLER_YCBCR_CONVERSION_KHR = 1000156000,
};


// ----------------------------------------- Flags ----------------------------------------

pub const InstanceCreateFlags = Flags;
pub const InstanceCreateFlagBits = struct {
	// No defined bits?
};

pub const FormatFeatureFlags = Flags;
pub const FormatFeatureFlagBits = struct {
    pub const SAMPLED_IMAGE_BIT: FormatFeatureFlags = 1;
    pub const STORAGE_IMAGE_BIT: FormatFeatureFlags = 2;
    pub const STORAGE_IMAGE_ATOMIC_BIT: FormatFeatureFlags = 4;
    pub const UNIFORM_TEXEL_BUFFER_BIT: FormatFeatureFlags = 8;
    pub const STORAGE_TEXEL_BUFFER_BIT: FormatFeatureFlags = 16;
    pub const STORAGE_TEXEL_BUFFER_ATOMIC_BIT: FormatFeatureFlags = 32;
    pub const VERTEX_BUFFER_BIT: FormatFeatureFlags = 64;
    pub const COLOR_ATTACHMENT_BIT: FormatFeatureFlags = 128;
    pub const COLOR_ATTACHMENT_BLEND_BIT: FormatFeatureFlags = 256;
    pub const DEPTH_STENCIL_ATTACHMENT_BIT: FormatFeatureFlags = 512;
    pub const BLIT_SRC_BIT: FormatFeatureFlags = 1024;
    pub const BLIT_DST_BIT: FormatFeatureFlags = 2048;
    pub const SAMPLED_IMAGE_FILTER_LINEAR_BIT: FormatFeatureFlags = 4096;
    pub const TRANSFER_SRC_BIT: FormatFeatureFlags = 16384;
    pub const TRANSFER_DST_BIT: FormatFeatureFlags = 32768;
    pub const MIDPOINT_CHROMA_SAMPLES_BIT: FormatFeatureFlags = 131072;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: FormatFeatureFlags = 262144;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: FormatFeatureFlags = 524288;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: FormatFeatureFlags = 1048576;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: FormatFeatureFlags = 2097152;
    pub const DISJOINT_BIT: FormatFeatureFlags = 4194304;
    pub const COSITED_CHROMA_SAMPLES_BIT: FormatFeatureFlags = 8388608;
    pub const SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG: FormatFeatureFlags = 8192;
    pub const SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT: FormatFeatureFlags = 65536;
    pub const TRANSFER_SRC_BIT_KHR: FormatFeatureFlags = 16384;
    pub const TRANSFER_DST_BIT_KHR: FormatFeatureFlags = 32768;
    pub const MIDPOINT_CHROMA_SAMPLES_BIT_KHR: FormatFeatureFlags = 131072;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR: FormatFeatureFlags = 262144;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR: FormatFeatureFlags = 524288;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR: FormatFeatureFlags = 1048576;
    pub const SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR: FormatFeatureFlags = 2097152;
    pub const DISJOINT_BIT_KHR: FormatFeatureFlags = 4194304;
    pub const COSITED_CHROMA_SAMPLES_BIT_KHR: FormatFeatureFlags = 8388608;
};

pub const ImageUsageFlags = Flags;
pub const ImageUsageFlagBits = struct {
	pub const TRANSFER_SRC_BIT: ImageUsageFlags = 1;
	pub const TRANSFER_DST_BIT: ImageUsageFlags = 2;
	pub const SAMPLED_BIT: ImageUsageFlags = 4;
	pub const STORAGE_BIT: ImageUsageFlags = 8;
	pub const COLOR_ATTACHMENT_BIT: ImageUsageFlags = 16;
	pub const DEPTH_STENCIL_ATTACHMENT_BIT: ImageUsageFlags = 32;
	pub const TRANSIENT_ATTACHMENT_BIT: ImageUsageFlags = 64;
	pub const INPUT_ATTACHMENT_BIT: ImageUsageFlags = 128;
};

pub const ImageCreateFlags = Flags;
pub const ImageCreateFlagBits = struct {
    pub const SPARSE_BINDING_BIT: ImageCreateFlags = 1;
    pub const SPARSE_RESIDENCY_BIT: ImageCreateFlags = 2;
    pub const SPARSE_ALIASED_BIT: ImageCreateFlags = 4;
    pub const MUTABLE_FORMAT_BIT: ImageCreateFlags = 8;
    pub const CUBE_COMPATIBLE_BIT: ImageCreateFlags = 16;
    pub const ALIAS_BIT: ImageCreateFlags = 1024;
    pub const SPLIT_INSTANCE_BIND_REGIONS_BIT: ImageCreateFlags = 64;
    pub const 2D_ARRAY_COMPATIBLE_BIT: ImageCreateFlags = 32;
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: ImageCreateFlags = 128;
    pub const EXTENDED_USAGE_BIT: ImageCreateFlags = 256;
    pub const PROTECTED_BIT: ImageCreateFlags = 2048;
    pub const DISJOINT_BIT: ImageCreateFlags = 512;
    pub const SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT: ImageCreateFlags = 4096;
    pub const SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: ImageCreateFlags = 64;
    pub const 2D_ARRAY_COMPATIBLE_BIT_KHR: ImageCreateFlags = 32;
    pub const BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR: ImageCreateFlags = 128;
    pub const EXTENDED_USAGE_BIT_KHR: ImageCreateFlags = 256;
    pub const DISJOINT_BIT_KHR: ImageCreateFlags = 512;
    pub const ALIAS_BIT_KHR: ImageCreateFlags = 1024;
};

pub const SampleCountFlags = Flags;
pub const SampleCountFlagBits = struct {
    pub const COUNT_1_BIT: SampleCountFlags = 1;
    pub const COUNT_2_BIT: SampleCountFlags = 2;
    pub const COUNT_4_BIT: SampleCountFlags = 4;
    pub const COUNT_8_BIT: SampleCountFlags = 8;
    pub const COUNT_16_BIT: SampleCountFlags = 16;
    pub const COUNT_32_BIT: SampleCountFlags = 32;
    pub const COUNT_64_BIT: SampleCountFlags = 64;
};

pub const QueueFlags = Flags;
pub const QueueFlagBits = struct {
	pub const GRAPHICS_BIT: QueueFlags = 1;
	pub const COMPUTE_BIT: QueueFlags = 2;
	pub const TRANSFER_BIT: QueueFlags = 4;
	pub const SPARSE_BINDING_BIT: QueueFlags = 8;
	pub const PROTECTED_BIT: QueueFlags = 16;
};

pub const MemoryPropertyFlags = Flags;
pub const MemoryPropertyFlagBits = struct {
    pub const DEVICE_LOCAL_BIT: MemoryPropertyFlags = 1;
    pub const HOST_VISIBLE_BIT: MemoryPropertyFlags = 2;
    pub const HOST_COHERENT_BIT: MemoryPropertyFlags = 4;
    pub const HOST_CACHED_BIT: MemoryPropertyFlags = 8;
    pub const LAZILY_ALLOCATED_BIT: MemoryPropertyFlags = 16;
    pub const PROTECTED_BIT: MemoryPropertyFlags = 32;
};

pub const MemoryHeapFlags = Flags;
pub const MemoryHeapFlagBits = struct {
    pub const DEVICE_LOCAL_BIT: MemoryHeapFlags = 1;
    pub const MULTI_INSTANCE_BIT: MemoryHeapFlags = 2;
    pub const MULTI_INSTANCE_BIT_KHR: MemoryHeapFlags = 2;
};

pub const DeviceQueueCreateFlags = Flags;
pub const DeviceQueueCreateFlagBits = struct {
    pub const PROTECTED_BIT = 1;
};

pub const PipelineStageFlags = Flags;
pub const PipelineStageFlagBits = struct {
	pub const TOP_OF_PIPE_BIT: PipelineStageFlags = 1;
	pub const DRAW_INDIRECT_BIT: PipelineStageFlags = 2;
	pub const VERTEX_INPUT_BIT: PipelineStageFlags = 4;
	pub const VERTEX_SHADER_BIT: PipelineStageFlags = 8;
	pub const TESSELLATION_CONTROL_SHADER_BIT: PipelineStageFlags = 16;
	pub const TESSELLATION_EVALUATION_SHADER_BIT: PipelineStageFlags = 32;
	pub const GEOMETRY_SHADER_BIT: PipelineStageFlags = 64;
	pub const FRAGMENT_SHADER_BIT: PipelineStageFlags = 128;
	pub const EARLY_FRAGMENT_TESTS_BIT: PipelineStageFlags = 256;
	pub const LATE_FRAGMENT_TESTS_BIT: PipelineStageFlags = 512;
	pub const COLOR_ATTACHMENT_OUTPUT_BIT: PipelineStageFlags = 1024;
	pub const COMPUTE_SHADER_BIT: PipelineStageFlags = 2048;
	pub const TRANSFER_BIT: PipelineStageFlags = 4096;
	pub const BOTTOM_OF_PIPE_BIT: PipelineStageFlags = 8192;
	pub const HOST_BIT: PipelineStageFlags = 16384;
	pub const ALL_GRAPHICS_BIT: PipelineStageFlags = 32768;
	pub const ALL_COMMANDS_BIT: PipelineStageFlags = 65536;
	pub const COMMAND_PROCESS_BIT_NVX: PipelineStageFlags = 131072;
}

pub const MemoryMapFlags = Flags;
pub const MemoryMapFlagBits = struct {
	// @TODO: Definitions missing?
};

pub const ImageAspectFlags = Flags;
pub const ImageAspectFlagBits = struct {
	pub const COLOR_BIT: ImageAspectFlags = 1;
	pub const DEPTH_BIT: ImageAspectFlags = 2;
	pub const STENCIL_BIT: ImageAspectFlags = 4;
	pub const METADATA_BIT: ImageAspectFlags = 8;
	pub const PLANE_0_BIT: ImageAspectFlags = 16;
	pub const PLANE_1_BIT: ImageAspectFlags = 32;
	pub const PLANE_2_BIT: ImageAspectFlags = 64;
	pub const PLANE_0_BIT_KHR: ImageAspectFlags = 16;
	pub const PLANE_1_BIT_KHR: ImageAspectFlags = 32;
	pub const PLANE_2_BIT_KHR: ImageAspectFlags = 64;
};

pub const SparseImageFormatFlags = Flags;
pub const SparseImageFormatFlagBits = struct {
    pub const SINGLE_MIPTAIL_BIT: SparseImageFormatFlags = 1;
    pub const ALIGNED_MIP_SIZE_BIT: SparseImageFormatFlags = 2;
    pub const NONSTANDARD_BLOCK_SIZE_BIT: SparseImageFormatFlags = 4;
};

pub const SparseMemoryBindFlags = Flags;
pub const SparseMemoryBindFlagBits = struct {
    pub const METADATA_BIT: SparseMemoryBindFlags = 1;
};

pub const FenceCreateFlags = Flags;
pub const FenceCreateFlagBits = struct {
	pub const SIGNALED_BIT: FenceCreateFlags = 1;
};

pub const SemaphoreCreateFlags = Flags;
pub const SemaphoreCreateFlagBits = struct {
	// No defined bits?
};

pub const EventCreateFlags = Flags;
pub const EventCreateFlagBits = struct {
	// No defined bits?
};

pub const QueryPoolCreateFlags = Flags;
pub const QueryPoolCreateFlagBits = struct {
	// No defined bits?
};

pub const QueryPipelineStatisticFlags = Flags;
pub const QueryPipelineStatisticFlagBits = struct {
    pub const INPUT_ASSEMBLY_VERTICES_BIT: QueryPipelineStatisticFlags = 1;
    pub const INPUT_ASSEMBLY_PRIMITIVES_BIT: QueryPipelineStatisticFlags = 2;
    pub const VERTEX_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 4;
    pub const GEOMETRY_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 8;
    pub const GEOMETRY_SHADER_PRIMITIVES_BIT: QueryPipelineStatisticFlags = 16;
    pub const CLIPPING_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 32;
    pub const CLIPPING_PRIMITIVES_BIT: QueryPipelineStatisticFlags = 64;
    pub const FRAGMENT_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 128;
    pub const TESSELLATION_CONTROL_SHADER_PATCHES_BIT: QueryPipelineStatisticFlags = 256;
    pub const TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 512;
    pub const COMPUTE_SHADER_INVOCATIONS_BIT: QueryPipelineStatisticFlags = 1024;
};

pub const QueryResultFlags = Flags;
pub const QueryResultFlagBits = struct {
    pub const IS_64_BIT: QueryResultFlags = 1;
    pub const WAIT_BIT: QueryResultFlags = 2;
    pub const WITH_AVAILABILITY_BIT: QueryResultFlags = 4;
    pub const PARTIAL_BIT: QueryResultFlags = 8;
};

pub const BufferCreateFlags = Flags;
pub const BufferCreateFlagBits = struct {
    pub const SPARSE_BINDING_BIT: BufferCreateFlags = 1;
    pub const SPARSE_RESIDENCY_BIT: BufferCreateFlags = 2;
    pub const SPARSE_ALIASED_BIT: BufferCreateFlags = 4;
    pub const PROTECTED_BIT: BufferCreateFlags = 8;
};

pub const BufferUsageFlags = Flags;
pub const BufferUsageFlagBits = struct {
    pub const TRANSFER_SRC_BIT: BufferUsageFlags = 1;
    pub const TRANSFER_DST_BIT: BufferUsageFlags = 2;
    pub const UNIFORM_TEXEL_BUFFER_BIT: BufferUsageFlags = 4;
    pub const STORAGE_TEXEL_BUFFER_BIT: BufferUsageFlags = 8;
    pub const UNIFORM_BUFFER_BIT: BufferUsageFlags = 16;
    pub const STORAGE_BUFFER_BIT: BufferUsageFlags = 32;
    pub const INDEX_BUFFER_BIT: BufferUsageFlags = 64;
    pub const VERTEX_BUFFER_BIT: BufferUsageFlags = 128;
    pub const INDIRECT_BUFFER_BIT: BufferUsageFlags = 256;
};

pub const BufferViewCreateFlags = Flags;
pub const BufferViewCreateFlagBits = struct {
	// No defined bits?
};

pub const ImageViewCreateFlags = Flags;
pub const ImageViewCreateFlagBits = struct {
	// No defined bits?
};

pub const ShaderModuleCreateFlags = Flags;
pub const ShaderModuleCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineCacheCreateFlags = Flags;
pub const PipelineCacheCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineCreateFlags = Flags;
pub const PipelineCreateFlagBits = struct {
    pub const DISABLE_OPTIMIZATION_BIT: PipelineCreateFlags = 1;
    pub const ALLOW_DERIVATIVES_BIT: PipelineCreateFlags = 2;
    pub const DERIVATIVE_BIT: PipelineCreateFlags = 4;
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_BIT: PipelineCreateFlags = 8;
    pub const DISPATCH_BASE: PipelineCreateFlags = 16;
    pub const VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR: PipelineCreateFlags = 8;
    pub const DISPATCH_BASE_KHR: PipelineCreateFlags = 16;
};

pub const PipelineShaderStageCreateFlags = Flags;
pub const PipelineShaderStageCreateFlagBits = struct {
	// No defined bits?
};

pub const ShaderStageFlags = Flags;
pub const ShaderStageFlagBits = struct {
    pub const VERTEX_BIT: ShaderStageFlags = 1;
    pub const TESSELLATION_CONTROL_BIT: ShaderStageFlags = 2;
    pub const TESSELLATION_EVALUATION_BIT: ShaderStageFlags = 4;
    pub const GEOMETRY_BIT: ShaderStageFlags = 8;
    pub const FRAGMENT_BIT: ShaderStageFlags = 16;
    pub const COMPUTE_BIT: ShaderStageFlags = 32;
    pub const ALL_GRAPHICS: ShaderStageFlags = 31;
};

pub const PipelineVertexInputStateCreateFlags = Flags;
pub const PipelineVertexInputStateCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineInputAssemblyStateCreateFlags = Flags;
pub const PipelineInputAssemblyStateCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineTessellationStateCreateFlags = Flags;
pub const PipelineTessellationStateCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineViewportStateCreateFlags = Flags;
pub const PipelineViewportStateCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineRasterizationStateCreateFlags = Flags;
pub const PipelineRasterizationStateCreateFlagBits = struct {
	// No defined bits?
};

pub const CullModeFlags = Flags;
pub const CullModeFlagBits = struct {
    pub const NONE: CullModeFlags = 0;
    pub const FRONT_BIT: CullModeFlags = 1;
    pub const BACK_BIT: CullModeFlags = 2;
    pub const FRONT_AND_BACK: CullModeFlags = 3;
};

pub const PipelineMultisampleStateCreateFlags = Flags;
pub const PipelineMultisampleStateCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineDepthStencilStateCreateFlags = Flags;
pub const PipelineDepthStencilStateCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineColorBlendStateCreateFlags = Flags;
pub const PipelineColorBlendStateCreateFlagBits = struct {
	// No defined bits?
};

pub const ColorComponentFlags = Flags;
pub const ColorComponentFlagBits = struct {
	pub const R_BIT: ColorComponentFlags = 1;
	pub const G_BIT: ColorComponentFlags = 2;
	pub const B_BIT: ColorComponentFlags = 4;
	pub const A_BIT: ColorComponentFlags = 8;
};

pub const PipelineDynamicStateCreateFlags = Flags;
pub const PipelineDynamicStateCreateFlagBits = struct {
	// No defined bits?
};

pub const PipelineLayoutCreateFlags = Flags;
pub const PipelineLayoutCreateFlagBits = struct {
	// No defined bits?
};

pub const ShaderStageFlags = Flags;
pub const ShaderStageFlagBits = struct {
	// No defined bits?
};

pub const SamplerCreateFlags = Flags;
pub const SamplerCreateFlagBits = struct {
	// No defined bits?
};

pub const DescriptorSetLayoutCreateFlags = Flags;
pub const DescriptorSetLayoutCreateFlagBits = struct {
    pub const PUSH_DESCRIPTOR_BIT_KHR: DescriptorSetLayoutCreateFlags = 1;
    pub const UPDATE_AFTER_BIND_POOL_BIT_EXT: DescriptorSetLayoutCreateFlags = 2;
};

pub const DescriptorPoolCreateFlags = Flags;
pub const DescriptorPoolCreateFlagBits = struct {
    pub const FREE_DESCRIPTOR_SET_BIT: DescriptorPoolCreateFlags = 1;
    pub const UPDATE_AFTER_BIND_BIT_EXT: DescriptorPoolCreateFlags = 2;
};

pub const DescriptorPoolResetFlags = Flags;
pub const FramebufferCreateFlags = Flags;
pub const RenderPassCreateFlags = Flags;

pub const AttachmentDescriptionFlags = Flags;
pub const AttachmentDescriptionFlagBits = struct {
    pub const MAY_ALIAS_BIT: AttachmentDescriptionFlags = 1;
};

pub const SubpassDescriptionFlags = Flags;
pub const SubpassDescriptionFlagBits = struct {
    pub const PER_VIEW_ATTRIBUTES_BIT_NVX: SubpassDescriptionFlags = 1;
    pub const PER_VIEW_POSITION_X_ONLY_BIT_NVX: SubpassDescriptionFlags = 2;
};

pub const AccessFlags = Flags;
pub const AccessFlagBits = struct {
	pub const INDIRECT_COMMAND_READ_BIT: AccessFlags = 1;
	pub const INDEX_READ_BIT: AccessFlags = 2;
	pub const VERTEX_ATTRIBUTE_READ_BIT: AccessFlags = 4;
	pub const UNIFORM_READ_BIT: AccessFlags = 8;
	pub const INPUT_ATTACHMENT_READ_BIT: AccessFlags = 16;
	pub const SHADER_READ_BIT: AccessFlags = 32;
	pub const SHADER_WRITE_BIT: AccessFlags = 64;
	pub const COLOR_ATTACHMENT_READ_BIT: AccessFlags = 128;
	pub const COLOR_ATTACHMENT_WRITE_BIT: AccessFlags = 256;
	pub const DEPTH_STENCIL_ATTACHMENT_READ_BIT: AccessFlags = 512;
	pub const DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: AccessFlags = 1024;
	pub const TRANSFER_READ_BIT: AccessFlags = 2048;
	pub const TRANSFER_WRITE_BIT: AccessFlags = 4096;
	pub const HOST_READ_BIT: AccessFlags = 8192;
	pub const HOST_WRITE_BIT: AccessFlags = 16384;
	pub const MEMORY_READ_BIT: AccessFlags = 32768;
	pub const MEMORY_WRITE_BIT: AccessFlags = 65536;
	pub const COMMAND_PROCESS_READ_BIT_NVX: AccessFlags = 131072;
	pub const COMMAND_PROCESS_WRITE_BIT_NVX: AccessFlags = 262144;
	pub const COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: AccessFlags = 524288;
};

pub const DependencyFlags = Flags;
pub const DependencyFlagBits = struct {
    pub const BY_REGION_BIT: DependencyFlags = 1;
    pub const DEVICE_GROUP_BIT: DependencyFlags = 4;
    pub const VIEW_LOCAL_BIT: DependencyFlags = 2;
    pub const VIEW_LOCAL_BIT_KHR: DependencyFlags = 2;
    pub const DEVICE_GROUP_BIT_KHR: DependencyFlags = 4;
};

pub const CommandPoolCreateFlags = Flags;
pub const CommandPoolCreateFlagBits = struct {
    pub const TRANSIENT_BIT: CommandPoolCreateFlags = 1;
    pub const RESET_COMMAND_BUFFER_BIT: CommandPoolCreateFlags = 2;
    pub const PROTECTED_BIT: CommandPoolCreateFlags = 4;
};

pub const CommandPoolResetFlags = Flags;
pub const CommandPoolResetFlagBits = struct {
    pub const RELEASE_RESOURCES_BIT: CommandPoolResetFlags = 1;
};

pub const CommandBufferUsageFlags = Flags;
pub const CommandBufferUsageFlagBits = struct {
	pub const ONE_TIME_SUBMIT_BIT: CommandBufferUsageFlags = 1;
	pub const RENDER_PASS_CONTINUE_BIT: CommandBufferUsageFlags = 2;
	pub const SIMULTANEOUS_USE_BIT: CommandBufferUsageFlags = 4;
};

pub const QueryControlFlags = Flags;
pub const QueryControlFlagBits = struct {
    pub const PRECISE_BIT: QueryControlFlags = 1;
};

pub const CommandBufferResetFlags = Flags;
pub const CommandBufferResetFlagBits = struct {
    pub const RELEASE_RESOURCES_BIT: CommandBufferResetFlags = 1;
};

pub const StencilFaceFlags = Flags;
pub const StencilFaceFlagBits = struct {
    pub const FRONT_BIT: StencilFaceFlags = 1;
    pub const BACK_BIT: StencilFaceFlags = 2;
    pub const FRONT_AND_BACK: StencilFaceFlags = 3;
};


// ----------------------------------------- Structures -----------------------------------------------

pub const CString = [*]const u8;

pub fn LongSlice(comptime T: type) type {
	return SliceSized(usize, T);
}

pub fn Slice(comptime T: type) type {
	return SliceSized(u32, T);
}

fn SliceSized(comptime SizeType: type, comptime T: type) type {
	return extern struct {
		const Self = @This();

		count: SizeType = 0,
		values: ?[*]const T = null,
		
		pub const Empty = Self{};
		
		pub fn init([]const T value) Self {
			return Self{
				.count = @intCast(SizeType, value.len),
				.values = value.ptr,
			};
		}
		
		pub fn initSingle(*const T value) Self {
			return Self{
				.count = 1,
				.values = @ptrCast([*]const T, value),
			};
		}
		
		pub fn get(self: Self) []const T {
			if (self.count == 0) return ([0]const T{})[0..0];
			else return self.values.?[0..self.count];
		}
	};
}

pub fn Slice2(comptime T1: type, comptime T2: type) type {
	return extern struct {
		const Self = @This();

		count: u32 = 0,
		values1: ?[*]const T1 = null,
		values2: ?[*]const T2 = null,
		
		pub const Empty = Self{};
		
		pub fn init([]const T1 value1, []const T2 value2) Self {
			@import("std").debug.assert(value1.len == value2.len);
			return Self{
				.count = @intCast(u32, value1.len),
				.values1 = value1.ptr,
				.values2 = value2.ptr,
			};
		}
		
		pub fn initSingle(*const T1 value1, *const T2 value2) Self {
			return Self{
				.count = 1,
				.values1 = @ptrCast([*]const T1, value1),
				.values2 = @ptrCast([*]const T2, value2),
			};
		}
	};
}

pub const ApplicationInfo = extern struct {
    sType: StructureType = .APPLICATION_INFO,
    pNext: ?*const c_void = null,
    pApplicationName: ?CString,
    applicationVersion: u32,
    pEngineName: ?CString,
    engineVersion: u32,
    apiVersion: u32,
};

pub const StringSlice = Slice(?CString);
pub const InstanceCreateInfo = extern struct {
    sType: StructureType = .INSTANCE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: InstanceCreateFlags = 0,
    pApplicationInfo: *const ApplicationInfo,
	enabledLayers: SliceString = SliceString.Empty;
	enabledExtensions: SliceString = SliceString.Empty;
};

pub const AllocationFunction = extern fn (?*c_void, usize, usize, SystemAllocationScope) ?*c_void;
pub const ReallocationFunction = extern fn (?*c_void, ?*c_void, usize, usize, SystemAllocationScope) ?*c_void;
pub const FreeFunction = extern fn (?*c_void, ?*c_void) void;
pub const InternalAllocationNotification = extern fn (?*c_void, usize, InternalAllocationType, SystemAllocationScope) void;
pub const InternalFreeNotification = extern fn (?*c_void, usize, InternalAllocationType, SystemAllocationScope) void;
pub const AllocationCallbacks = extern struct {
    pUserData: ?*c_void,
    pfnAllocation: ?AllocationFunction,
    pfnReallocation: ?ReallocationFunction,
    pfnFree: ?FreeFunction,
    pfnInternalAllocation: ?InternalAllocationNotification,
    pfnInternalFree: ?InternalFreeNotification,
};

pub const PhysicalDeviceFeatures = extern struct {
    robustBufferAccess: Bool32,
    fullDrawIndexUint32: Bool32,
    imageCubeArray: Bool32,
    independentBlend: Bool32,
    geometryShader: Bool32,
    tessellationShader: Bool32,
    sampleRateShading: Bool32,
    dualSrcBlend: Bool32,
    logicOp: Bool32,
    multiDrawIndirect: Bool32,
    drawIndirectFirstInstance: Bool32,
    depthClamp: Bool32,
    depthBiasClamp: Bool32,
    fillModeNonSolid: Bool32,
    depthBounds: Bool32,
    wideLines: Bool32,
    largePoints: Bool32,
    alphaToOne: Bool32,
    multiViewport: Bool32,
    samplerAnisotropy: Bool32,
    textureCompressionETC2: Bool32,
    textureCompressionASTC_LDR: Bool32,
    textureCompressionBC: Bool32,
    occlusionQueryPrecise: Bool32,
    pipelineStatisticsQuery: Bool32,
    vertexPipelineStoresAndAtomics: Bool32,
    fragmentStoresAndAtomics: Bool32,
    shaderTessellationAndGeometryPointSize: Bool32,
    shaderImageGatherExtended: Bool32,
    shaderStorageImageExtendedFormats: Bool32,
    shaderStorageImageMultisample: Bool32,
    shaderStorageImageReadWithoutFormat: Bool32,
    shaderStorageImageWriteWithoutFormat: Bool32,
    shaderUniformBufferArrayDynamicIndexing: Bool32,
    shaderSampledImageArrayDynamicIndexing: Bool32,
    shaderStorageBufferArrayDynamicIndexing: Bool32,
    shaderStorageImageArrayDynamicIndexing: Bool32,
    shaderClipDistance: Bool32,
    shaderCullDistance: Bool32,
    shaderFloat64: Bool32,
    shaderInt64: Bool32,
    shaderInt16: Bool32,
    shaderResourceResidency: Bool32,
    shaderResourceMinLod: Bool32,
    sparseBinding: Bool32,
    sparseResidencyBuffer: Bool32,
    sparseResidencyImage2D: Bool32,
    sparseResidencyImage3D: Bool32,
    sparseResidency2Samples: Bool32,
    sparseResidency4Samples: Bool32,
    sparseResidency8Samples: Bool32,
    sparseResidency16Samples: Bool32,
    sparseResidencyAliased: Bool32,
    variableMultisampleRate: Bool32,
    inheritedQueries: Bool32,
};

pub const FormatProperties = extern struct {
    linearTilingFeatures: FormatFeatureFlags,
    optimalTilingFeatures: FormatFeatureFlags,
    bufferFeatures: FormatFeatureFlags,
};

pub const Extent3D = extern struct {
    width: u32,
    height: u32,
    depth: u32,
};

pub const ImageFormatProperties = extern struct {
    maxExtent: Extent3D,
    maxMipLevels: u32,
    maxArrayLayers: u32,
    sampleCounts: SampleCountFlags,
    maxResourceSize: DeviceSize,
};

pub const PhysicalDeviceLimits = extern struct {
    maxImageDimension1D: u32,
    maxImageDimension2D: u32,
    maxImageDimension3D: u32,
    maxImageDimensionCube: u32,
    maxImageArrayLayers: u32,
    maxTexelBufferElements: u32,
    maxUniformBufferRange: u32,
    maxStorageBufferRange: u32,
    maxPushConstantsSize: u32,
    maxMemoryAllocationCount: u32,
    maxSamplerAllocationCount: u32,
    bufferImageGranularity: DeviceSize,
    sparseAddressSpaceSize: DeviceSize,
    maxBoundDescriptorSets: u32,
    maxPerStageDescriptorSamplers: u32,
    maxPerStageDescriptorUniformBuffers: u32,
    maxPerStageDescriptorStorageBuffers: u32,
    maxPerStageDescriptorSampledImages: u32,
    maxPerStageDescriptorStorageImages: u32,
    maxPerStageDescriptorInputAttachments: u32,
    maxPerStageResources: u32,
    maxDescriptorSetSamplers: u32,
    maxDescriptorSetUniformBuffers: u32,
    maxDescriptorSetUniformBuffersDynamic: u32,
    maxDescriptorSetStorageBuffers: u32,
    maxDescriptorSetStorageBuffersDynamic: u32,
    maxDescriptorSetSampledImages: u32,
    maxDescriptorSetStorageImages: u32,
    maxDescriptorSetInputAttachments: u32,
    maxVertexInputAttributes: u32,
    maxVertexInputBindings: u32,
    maxVertexInputAttributeOffset: u32,
    maxVertexInputBindingStride: u32,
    maxVertexOutputComponents: u32,
    maxTessellationGenerationLevel: u32,
    maxTessellationPatchSize: u32,
    maxTessellationControlPerVertexInputComponents: u32,
    maxTessellationControlPerVertexOutputComponents: u32,
    maxTessellationControlPerPatchOutputComponents: u32,
    maxTessellationControlTotalOutputComponents: u32,
    maxTessellationEvaluationInputComponents: u32,
    maxTessellationEvaluationOutputComponents: u32,
    maxGeometryShaderInvocations: u32,
    maxGeometryInputComponents: u32,
    maxGeometryOutputComponents: u32,
    maxGeometryOutputVertices: u32,
    maxGeometryTotalOutputComponents: u32,
    maxFragmentInputComponents: u32,
    maxFragmentOutputAttachments: u32,
    maxFragmentDualSrcAttachments: u32,
    maxFragmentCombinedOutputResources: u32,
    maxComputeSharedMemorySize: u32,
    maxComputeWorkGroupCount: [3]u32,
    maxComputeWorkGroupInvocations: u32,
    maxComputeWorkGroupSize: [3]u32,
    subPixelPrecisionBits: u32,
    subTexelPrecisionBits: u32,
    mipmapPrecisionBits: u32,
    maxDrawIndexedIndexValue: u32,
    maxDrawIndirectCount: u32,
    maxSamplerLodBias: f32,
    maxSamplerAnisotropy: f32,
    maxViewports: u32,
    maxViewportDimensions: [2]u32,
    viewportBoundsRange: [2]f32,
    viewportSubPixelBits: u32,
    minMemoryMapAlignment: usize,
    minTexelBufferOffsetAlignment: DeviceSize,
    minUniformBufferOffsetAlignment: DeviceSize,
    minStorageBufferOffsetAlignment: DeviceSize,
    minTexelOffset: i32,
    maxTexelOffset: u32,
    minTexelGatherOffset: i32,
    maxTexelGatherOffset: u32,
    minInterpolationOffset: f32,
    maxInterpolationOffset: f32,
    subPixelInterpolationOffsetBits: u32,
    maxFramebufferWidth: u32,
    maxFramebufferHeight: u32,
    maxFramebufferLayers: u32,
    framebufferColorSampleCounts: SampleCountFlags,
    framebufferDepthSampleCounts: SampleCountFlags,
    framebufferStencilSampleCounts: SampleCountFlags,
    framebufferNoAttachmentsSampleCounts: SampleCountFlags,
    maxColorAttachments: u32,
    sampledImageColorSampleCounts: SampleCountFlags,
    sampledImageIntegerSampleCounts: SampleCountFlags,
    sampledImageDepthSampleCounts: SampleCountFlags,
    sampledImageStencilSampleCounts: SampleCountFlags,
    storageImageSampleCounts: SampleCountFlags,
    maxSampleMaskWords: u32,
    timestampComputeAndGraphics: Bool32,
    timestampPeriod: f32,
    maxClipDistances: u32,
    maxCullDistances: u32,
    maxCombinedClipAndCullDistances: u32,
    discreteQueuePriorities: u32,
    pointSizeRange: [2]f32,
    lineWidthRange: [2]f32,
    pointSizeGranularity: f32,
    lineWidthGranularity: f32,
    strictLines: Bool32,
    standardSampleLocations: Bool32,
    optimalBufferCopyOffsetAlignment: DeviceSize,
    optimalBufferCopyRowPitchAlignment: DeviceSize,
    nonCoherentAtomSize: DeviceSize,
};

pub const PhysicalDeviceSparseProperties = extern struct {
    residencyStandard2DBlockShape: Bool32,
    residencyStandard2DMultisampleBlockShape: Bool32,
    residencyStandard3DBlockShape: Bool32,
    residencyAlignedMipSize: Bool32,
    residencyNonResidentStrict: Bool32,
};

pub const PhysicalDeviceProperties = extern struct {
    apiVersion: u32,
    driverVersion: u32,
    vendorID: u32,
    deviceID: u32,
    deviceType: PhysicalDeviceType,
    deviceName: [256]u8,
    pipelineCacheUUID: [16]u8,
    limits: PhysicalDeviceLimits,
    sparseProperties: PhysicalDeviceSparseProperties,
};

pub const QueueFamilyProperties = extern struct {
    queueFlags: QueueFlags,
    queueCount: u32,
    timestampValidBits: u32,
    minImageTransferGranularity: Extent3D,
};

pub const MemoryType = extern struct {
    propertyFlags: MemoryPropertyFlags,
    heapIndex: u32,
};

pub const MemoryHeap = extern struct {
    size: DeviceSize,
    flags: MemoryHeapFlags,
};

pub const VoidFunction = extern fn () void;
pub const SliceFloat = Slice(f32);
pub const DeviceQueueCreateInfo = extern struct {
    sType: StructureType = .DEVICE_QUEUE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DeviceQueueCreateFlags = 0,
    queueFamilyIndex: u32,
	queuePriorities: SliceFloat,
};

pub const DeviceCreateInfo = extern struct {
    sType: StructureType = .DEVICE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DeviceCreateFlags = 0,
	queueCreateInfos: Slice(DeviceQueueCreateInfo),
	enabledLayers: SliceString,
	enabledExtensions: SliceString,
    pEnabledFeatures: ?*const PhysicalDeviceFeatures,
};

pub const ExtensionProperties = extern struct {
    extensionName: [256]u8,
    specVersion: u32,
};

pub const LayerProperties = extern struct {
    layerName: [256]u8,
    specVersion: u32,
    implementationVersion: u32,
    description: [256]u8,
};

pub const SubmitInfo = extern struct {
    sType: StructureType = .SUBMIT_INFO,
    pNext: ?*const c_void = null,
	waitSemaphores: Slice2(Semaphore, PipelineStageFlags),
	commandBuffers: Slice(CommandBuffer),
	signalSemaphores: Slice(Semaphore),
};

pub const MemoryAllocateInfo = extern struct {
    sType: StructureType = .MEMORY_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    allocationSize: DeviceSize,
    memoryTypeIndex: u32,
};

pub const MappedMemoryRange = extern struct {
    sType: StructureType = .MAPPED_MEMORY_RANGE,
    pNext: ?*const c_void = null,
    memory: DeviceMemory,
    offset: DeviceSize,
    size: DeviceSize,
};

pub const MemoryRequirements = extern struct {
    size: DeviceSize,
    alignment: DeviceSize,
    memoryTypeBits: u32,
};

pub const SparseImageFormatProperties = extern struct {
    aspectMask: ImageAspectFlags,
    imageGranularity: Extent3D,
    flags: SparseImageFormatFlags,
};

pub const SparseImageMemoryRequirements = extern struct {
    formatProperties: SparseImageFormatProperties,
    imageMipTailFirstLod: u32,
    imageMipTailSize: DeviceSize,
    imageMipTailOffset: DeviceSize,
    imageMipTailStride: DeviceSize,
};

pub const SparseMemoryBind = extern struct {
    resourceOffset: DeviceSize,
    size: DeviceSize,
    memory: DeviceMemory,
    memoryOffset: DeviceSize,
    flags: SparseMemoryBindFlags,
};

pub const SparseBufferMemoryBindInfo = extern struct {
    buffer: Buffer,
	binds: Slice(SparseMemoryBind),
};

pub const SparseImageOpaqueMemoryBindInfo = extern struct {
    image: Image,
	binds: Slice(SparseMemoryBind),
};

pub const ImageSubresource = extern struct {
    aspectMask: ImageAspectFlags,
    mipLevel: u32,
    arrayLayer: u32,
};

pub const Offset3D = extern struct {
    x: i32,
    y: i32,
    z: i32,
};

pub const SparseImageMemoryBind = extern struct {
    subresource: ImageSubresource,
    offset: Offset3D,
    extent: Extent3D,
    memory: DeviceMemory,
    memoryOffset: DeviceSize,
    flags: SparseMemoryBindFlags,
};

pub const SparseImageMemoryBindInfo = extern struct {
    image: Image,
	binds: Slice(SparseImageMemoryBind),
};

pub const BindSparseInfo = extern struct {
    sType: StructureType = .BIND_SPARSE_INFO,
    pNext: ?*const c_void = null,
	waitSemaphores: Slice(Semaphore),
	bufferBinds: Slice(SparseBufferMemoryBindInfo),
	imageOpaqueBinds: Slice(SparseImageOpaqueMemoryBindInfo),
	imageBinds: Slice(SparseImageMemoryBindInfo),
	signalSemaphores: Slice(Semaphore),
};

pub const FenceCreateInfo = extern struct {
    sType: StructureType = .FENCE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: FenceCreateFlags = 0,
};

pub const SemaphoreCreateInfo = extern struct {
    sType: StructureType = .SEMAPHORE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: SemaphoreCreateFlags = 0,
};

pub const EventCreateInfo = extern struct {
    sType: StructureType = .EVENT_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: EventCreateFlags = 0,
};

pub const QueryPoolCreateInfo = extern struct {
    sType: StructureType = .QUERY_POOL_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: QueryPoolCreateFlags = 0,
    queryType: QueryType,
    queryCount: u32,
    pipelineStatistics: QueryPipelineStatisticFlags,
};

pub const BufferCreateInfo = extern struct {
    sType: StructureType = .BUFFER_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: BufferCreateFlags = 0,
    size: DeviceSize,
    usage: BufferUsageFlags,
    sharingMode: SharingMode,
	queueFamilyIndices: Slice(u32),
};

pub const BufferViewCreateInfo = extern struct {
    sType: StructureType = .BUFFER_VIEW_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: BufferViewCreateFlags = 0,
    buffer: Buffer,
    format: Format,
    offset: DeviceSize,
    range: DeviceSize,
};

pub const ImageCreateInfo = extern struct {
    sType: StructureType = .IMAGE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: ImageCreateFlags = 0,
    imageType: ImageType,
    format: Format,
    extent: Extent3D,
    mipLevels: u32,
    arrayLayers: u32,
    samples: SampleCountFlags,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    sharingMode: SharingMode,
	queueFamilyIndices: Slice(u32),
    initialLayout: ImageLayout,
};

pub const SubresourceLayout = extern struct {
    offset: DeviceSize,
    size: DeviceSize,
    rowPitch: DeviceSize,
    arrayPitch: DeviceSize,
    depthPitch: DeviceSize,
};

pub const ComponentMapping = extern struct {
    r: ComponentSwizzle = .IDENTITY,
    g: ComponentSwizzle = .IDENTITY,
    b: ComponentSwizzle = .IDENTITY,
    a: ComponentSwizzle = .IDENTITY,
};

pub const ImageSubresourceRange = extern struct {
    aspectMask: ImageAspectFlags,
    baseMipLevel: u32,
    levelCount: u32,
    baseArrayLayer: u32,
    layerCount: u32,
};

pub const ImageViewCreateInfo = extern struct {
    sType: StructureType = .IMAGE_VIEW_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: ImageViewCreateFlags = 0,
    image: Image,
    viewType: ImageViewType,
    format: Format,
    components: ComponentMapping = ComponentMapping{},
    subresourceRange: ImageSubresourceRange,
};

pub const ShaderModuleCreateInfo = extern struct {
    sType: StructureType = .SHADER_MODULE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: ShaderModuleCreateFlags = 0,
	code: LongSlice(u32),
};

pub const PipelineCacheCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_CACHE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineCacheCreateFlags = 0,
    initialDataSize: usize,
    pInitialData: ?*const c_void,
};

pub const SpecializationMapEntry = extern struct {
    constantID: u32,
    offset: u32,
    size: usize,
};

pub const SpecializationInfo = extern struct {
	mapEntries: Slice(SpecializationMapEntry),
    dataSize: usize,
    pData: ?*const c_void,
};

pub const PipelineShaderStageCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_SHADER_STAGE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineShaderStageCreateFlags = 0,
    stage: ShaderStageFlags,
    module: ShaderModule,
    pName: ?CString,
    pSpecializationInfo: ?*const SpecializationInfo = null,
};

pub const VertexInputBindingDescription = extern struct {
    binding: u32,
    stride: u32,
    inputRate: VertexInputRate,
};

pub const VertexInputAttributeDescription = extern struct {
    location: u32,
    binding: u32,
    format: Format,
    offset: u32,
};

pub const PipelineVertexInputStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineVertexInputStateCreateFlags = 0,
    vertexBindingDescriptionCount: u32, // TODO: Can't use Slice here because of packing issues
    pVertexBindingDescriptions: ?[*]const VertexInputBindingDescription,
    vertexAttributeDescriptionCount: u32,
    pVertexAttributeDescriptions: ?[*]const VertexInputAttributeDescription,
};

pub const PipelineInputAssemblyStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineInputAssemblyStateCreateFlags = 0,
    topology: PrimitiveTopology,
    primitiveRestartEnable: Bool32,
};

pub const PipelineTessellationStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_TESSELLATION_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineTessellationStateCreateFlags = 0,
    patchControlPoints: u32,
};

pub const Viewport = extern struct {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    minDepth: f32,
    maxDepth: f32,
};

pub const Offset2D = extern struct {
    x: i32,
    y: i32,
};

pub const Extent2D = extern struct {
    width: u32,
    height: u32,
};

pub const Rect2D = extern struct {
    offset: Offset2D,
    extent: Extent2D,
};

pub const PipelineViewportStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineViewportStateCreateFlags = 0,
    viewportCount: u32,
    pViewports: ?[*]const Viewport,
    scissorCount: u32,
    pScissors: ?[*]const Rect2D,
};

pub const PipelineRasterizationStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineRasterizationStateCreateFlags = 0,
    depthClampEnable: Bool32,
    rasterizerDiscardEnable: Bool32,
    polygonMode: PolygonMode,
    cullMode: CullModeFlags,
    frontFace: FrontFace,
    depthBiasEnable: Bool32,
    depthBiasConstantFactor: f32,
    depthBiasClamp: f32,
    depthBiasSlopeFactor: f32,
    lineWidth: f32,
};

pub const PipelineMultisampleStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineMultisampleStateCreateFlags = 0,
    rasterizationSamples: SampleCountFlags,
    sampleShadingEnable: Bool32,
    minSampleShading: f32,
    pSampleMask: ?[*]const SampleMask,
    alphaToCoverageEnable: Bool32,
    alphaToOneEnable: Bool32,
};

pub const StencilOpState = extern struct {
    failOp: StencilOp,
    passOp: StencilOp,
    depthFailOp: StencilOp,
    compareOp: CompareOp,
    compareMask: u32,
    writeMask: u32,
    reference: u32,
};

pub const PipelineDepthStencilStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineDepthStencilStateCreateFlags = 0,
    depthTestEnable: Bool32,
    depthWriteEnable: Bool32,
    depthCompareOp: CompareOp,
    depthBoundsTestEnable: Bool32,
    stencilTestEnable: Bool32,
    front: StencilOpState,
    back: StencilOpState,
    minDepthBounds: f32,
    maxDepthBounds: f32,
};

pub const PipelineColorBlendAttachmentState = extern struct {
    blendEnable: Bool32,
    srcColorBlendFactor: BlendFactor,
    dstColorBlendFactor: BlendFactor,
    colorBlendOp: BlendOp,
    srcAlphaBlendFactor: BlendFactor,
    dstAlphaBlendFactor: BlendFactor,
    alphaBlendOp: BlendOp,
    colorWriteMask: ColorComponentFlags,
};

pub const PipelineColorBlendStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineColorBlendStateCreateFlags = 0,
    logicOpEnable: Bool32,
    logicOp: LogicOp,
    attachmentCount: u32,
    pAttachments: ?[*]const PipelineColorBlendAttachmentState,
    blendConstants: [4]f32,
};

pub const PipelineDynamicStateCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineDynamicStateCreateFlags = 0,
    dynamicStateCount: u32,
    pDynamicStates: ?[*]const DynamicState,
};

pub const GraphicsPipelineCreateInfo = extern struct {
    sType: StructureType = .GRAPHICS_PIPELINE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineCreateFlags = 0,
    stageCount: u32,
    pStages: ?[*]const PipelineShaderStageCreateInfo,
    pVertexInputState: *const PipelineVertexInputStateCreateInfo,
    pInputAssemblyState: *const PipelineInputAssemblyStateCreateInfo,
    pTessellationState: ?*const PipelineTessellationStateCreateInfo,
    pViewportState: ?*const PipelineViewportStateCreateInfo,
    pRasterizationState: *const PipelineRasterizationStateCreateInfo,
    pMultisampleState: ?*const PipelineMultisampleStateCreateInfo,
    pDepthStencilState: ?*const PipelineDepthStencilStateCreateInfo,
    pColorBlendState: ?*const PipelineColorBlendStateCreateInfo,
    pDynamicState: ?*const PipelineDynamicStateCreateInfo,
    layout: PipelineLayout,
    renderPass: RenderPass,
    subpass: u32,
    basePipelineHandle: Pipeline,
    basePipelineIndex: i32,
};

pub const ComputePipelineCreateInfo = extern struct {
    sType: StructureType = .COMPUTE_PIPELINE_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineCreateFlags = 0,
    stage: PipelineShaderStageCreateInfo,
    layout: PipelineLayout,
    basePipelineHandle: Pipeline,
    basePipelineIndex: i32,
};

pub const PushConstantRange = extern struct {
    stageFlags: ShaderStageFlags,
    offset: u32,
    size: u32,
};

pub const PipelineLayoutCreateInfo = extern struct {
    sType: StructureType = .PIPELINE_LAYOUT_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: PipelineLayoutCreateFlags = 0,
    setLayoutCount: u32,
    pSetLayouts: ?[*]const DescriptorSetLayout,
    pushConstantRangeCount: u32,
    pPushConstantRanges: ?[*]const PushConstantRange,
};

pub const SamplerCreateInfo = extern struct {
    sType: StructureType = .SAMPLER_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: SamplerCreateFlags = 0,
    magFilter: Filter,
    minFilter: Filter,
    mipmapMode: SamplerMipmapMode,
    addressModeU: SamplerAddressMode,
    addressModeV: SamplerAddressMode,
    addressModeW: SamplerAddressMode,
    mipLodBias: f32,
    anisotropyEnable: Bool32,
    maxAnisotropy: f32,
    compareEnable: Bool32,
    compareOp: CompareOp,
    minLod: f32,
    maxLod: f32,
    borderColor: BorderColor,
    unnormalizedCoordinates: Bool32,
};

pub const DescriptorSetLayoutBinding = extern struct {
    binding: u32,
    descriptorType: DescriptorType,
    descriptorCount: u32,
    stageFlags: ShaderStageFlags,
    pImmutableSamplers: ?[*]const Sampler,
};

pub const DescriptorSetLayoutCreateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DescriptorSetLayoutCreateFlags = 0,
    bindingCount: u32,
    pBindings: ?[*]const DescriptorSetLayoutBinding,
};

pub const DescriptorPoolSize = extern struct {
    descriptorType: DescriptorType,
    descriptorCount: u32,
};

pub const DescriptorPoolCreateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_POOL_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: DescriptorPoolCreateFlags = 0,
    maxSets: u32,
    poolSizeCount: u32,
    pPoolSizes: ?[*]const DescriptorPoolSize,
};

pub const DescriptorSetAllocateInfo = extern struct {
    sType: StructureType = .DESCRIPTOR_SET_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    descriptorPool: DescriptorPool,
    descriptorSetCount: u32,
    pSetLayouts: ?[*]const DescriptorSetLayout,
};

pub const DescriptorImageInfo = extern struct {
    sampler: Sampler,
    imageView: ImageView,
    imageLayout: ImageLayout,
};

pub const DescriptorBufferInfo = extern struct {
    buffer: Buffer,
    offset: DeviceSize,
    range: DeviceSize,
};

pub const WriteDescriptorSet = extern struct {
    sType: StructureType = .WRITE_DESCRIPTOR_SET,
    pNext: ?*const c_void = null,
    dstSet: DescriptorSet,
    dstBinding: u32,
    dstArrayElement: u32,
    descriptorCount: u32,
    descriptorType: DescriptorType,
    pImageInfo: ?[*]const DescriptorImageInfo,
    pBufferInfo: ?[*]const DescriptorBufferInfo,
    pTexelBufferView: ?[*]const BufferView,
};

pub const CopyDescriptorSet = extern struct {
    sType: StructureType = .COPY_DESCRIPTOR_SET,
    pNext: ?*const c_void = null,
    srcSet: DescriptorSet,
    srcBinding: u32,
    srcArrayElement: u32,
    dstSet: DescriptorSet,
    dstBinding: u32,
    dstArrayElement: u32,
    descriptorCount: u32,
};

pub const FramebufferCreateInfo = extern struct {
    sType: StructureType = .FRAMEBUFFER_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: FramebufferCreateFlags = 0,
    renderPass: RenderPass,
    attachmentCount: u32,
    pAttachments: ?[*]const ImageView,
    width: u32,
    height: u32,
    layers: u32,
};

pub const AttachmentDescription = extern struct {
    flags: AttachmentDescriptionFlags,
    format: Format,
    samples: SampleCountFlags,
    loadOp: AttachmentLoadOp,
    storeOp: AttachmentStoreOp,
    stencilLoadOp: AttachmentLoadOp,
    stencilStoreOp: AttachmentStoreOp,
    initialLayout: ImageLayout,
    finalLayout: ImageLayout,
};

pub const AttachmentReference = extern struct {
    attachment: u32,
    layout: ImageLayout,
};

pub const SubpassDescription = extern struct {
    flags: SubpassDescriptionFlags,
    pipelineBindPoint: PipelineBindPoint,
    inputAttachmentCount: u32,
    pInputAttachments: ?[*]const AttachmentReference,
    colorAttachmentCount: u32,
    pColorAttachments: ?[*]const AttachmentReference,
    pResolveAttachments: ?[*]const AttachmentReference,
    pDepthStencilAttachment: ?[*]const AttachmentReference,
    preserveAttachmentCount: u32,
    pPreserveAttachments: ?[*]const u32,
};

pub const SubpassDependency = extern struct {
    srcSubpass: u32,
    dstSubpass: u32,
    srcStageMask: PipelineStageFlags,
    dstStageMask: PipelineStageFlags,
    srcAccessMask: AccessFlags,
    dstAccessMask: AccessFlags,
    dependencyFlags: DependencyFlags,
};

pub const RenderPassCreateInfo = extern struct {
    sType: StructureType = .RENDER_PASS_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: RenderPassCreateFlags = 0,
    attachmentCount: u32,
    pAttachments: ?[*]const AttachmentDescription,
    subpassCount: u32,
    pSubpasses: ?[*]const SubpassDescription,
    dependencyCount: u32,
    pDependencies: ?[*]const SubpassDependency,
};

pub const CommandPoolCreateInfo = extern struct {
    sType: StructureType = .COMMAND_POOL_CREATE_INFO,
    pNext: ?*const c_void = null,
    flags: CommandPoolCreateFlags = 0,
    queueFamilyIndex: u32,
};

pub const CommandBufferAllocateInfo = extern struct {
    sType: StructureType = .COMMAND_BUFFER_ALLOCATE_INFO,
    pNext: ?*const c_void = null,
    commandPool: CommandPool,
    level: CommandBufferLevel,
    commandBufferCount: u32,
};

pub const CommandBufferInheritanceInfo = extern struct {
    sType: StructureType = .COMMAND_BUFFER_INHERITANCE_INFO,
    pNext: ?*const c_void = null,
    renderPass: RenderPass,
    subpass: u32,
    framebuffer: Framebuffer,
    occlusionQueryEnable: Bool32,
    queryFlags: QueryControlFlags,
    pipelineStatistics: QueryPipelineStatisticFlags,
};

pub const CommandBufferBeginInfo = extern struct {
    sType: StructureType = .COMMAND_BUFFER_BEGIN_INFO,
    pNext: ?*const c_void = null,
    flags: CommandBufferUsageFlags,
    pInheritanceInfo: ?*const CommandBufferInheritanceInfo = null,
};

pub const BufferCopy = extern struct {
    srcOffset: DeviceSize,
    dstOffset: DeviceSize,
    size: DeviceSize,
};

pub const ImageSubresourceLayers = extern struct {
    aspectMask: ImageAspectFlags,
    mipLevel: u32,
    baseArrayLayer: u32,
    layerCount: u32,
};

pub const ImageCopy = extern struct {
    srcSubresource: ImageSubresourceLayers,
    srcOffset: Offset3D,
    dstSubresource: ImageSubresourceLayers,
    dstOffset: Offset3D,
    extent: Extent3D,
};

pub const ImageBlit = extern struct {
    srcSubresource: ImageSubresourceLayers,
    srcOffsets: [2]Offset3D,
    dstSubresource: ImageSubresourceLayers,
    dstOffsets: [2]Offset3D,
};

pub const BufferImageCopy = extern struct {
    bufferOffset: DeviceSize,
    bufferRowLength: u32,
    bufferImageHeight: u32,
    imageSubresource: ImageSubresourceLayers,
    imageOffset: Offset3D,
    imageExtent: Extent3D,
};

pub const ClearColorValue = extern union {
    float32: [4]f32,
    int32: [4]i32,
    uint32: [4]u32,
};

pub const ClearDepthStencilValue = extern struct {
    depth: f32,
    stencil: u32,
};

pub const ClearValue = extern union {
    color: ClearColorValue,
    depthStencil: ClearDepthStencilValue,
};

pub const ClearAttachment = extern struct {
    aspectMask: ImageAspectFlags,
    colorAttachment: u32,
    clearValue: ClearValue,
};

pub const ClearRect = extern struct {
    rect: Rect2D,
    baseArrayLayer: u32,
    layerCount: u32,
};

pub const ImageResolve = extern struct {
    srcSubresource: ImageSubresourceLayers,
    srcOffset: Offset3D,
    dstSubresource: ImageSubresourceLayers,
    dstOffset: Offset3D,
    extent: Extent3D,
};

pub const MemoryBarrier = extern struct {
    sType: StructureType = .MEMORY_BARRIER,
    pNext: ?*const c_void = null,
    srcAccessMask: AccessFlags,
    dstAccessMask: AccessFlags,
};

pub const BufferMemoryBarrier = extern struct {
    sType: StructureType = .BUFFER_MEMORY_BARRIER,
    pNext: ?*const c_void = null,
    srcAccessMask: AccessFlags,
    dstAccessMask: AccessFlags,
    srcQueueFamilyIndex: u32,
    dstQueueFamilyIndex: u32,
    buffer: Buffer,
    offset: DeviceSize,
    size: DeviceSize,
};

pub const ImageMemoryBarrier = extern struct {
    sType: StructureType = .IMAGE_MEMORY_BARRIER,
    pNext: ?*const c_void = null,
    srcAccessMask: AccessFlags,
    dstAccessMask: AccessFlags,
    oldLayout: ImageLayout,
    newLayout: ImageLayout,
    srcQueueFamilyIndex: u32,
    dstQueueFamilyIndex: u32,
    image: Image,
    subresourceRange: ImageSubresourceRange,
};

pub const RenderPassBeginInfo = extern struct {
    sType: StructureType = .RENDER_PASS_BEGIN_INFO,
    pNext: ?*const c_void = 0,
    renderPass: RenderPass,
    framebuffer: Framebuffer,
    renderArea: Rect2D,
    clearValueCount: u32,
    pClearValues: ?[*]const ClearValue,
};

pub const DispatchIndirectCommand = extern struct {
    x: u32,
    y: u32,
    z: u32,
};

pub const DrawIndexedIndirectCommand = extern struct {
    indexCount: u32,
    instanceCount: u32,
    firstIndex: u32,
    vertexOffset: i32,
    firstInstance: u32,
};

pub const DrawIndirectCommand = extern struct {
    vertexCount: u32,
    instanceCount: u32,
    firstVertex: u32,
    firstInstance: u32,
};

pub const BaseOutStructure = extern struct {
    sType: StructureType,
    pNext: ?*BaseOutStructure,
};

pub const BaseInStructure = extern struct {
    sType: StructureType,
    pNext: ?*const BaseInStructure,
};



// ------------------------------------ Functions: Object Management -----------------------------------------------

noinline fn mapError(result: Result) !noreturn {
	switch (result) {
		.SUCCESS => unreachable,
	    .NOT_READY => return error.VK_NOT_READY,
		.TIMEOUT => return error.VK_TIMEOUT,
		.EVENT_SET => return error.VK_EVENT_SET,
		.EVENT_RESET => return error.VK_EVENT_RESET,
		.INCOMPLETE => return error.VK_INCOMPLETE,
		.ERROR_OUT_OF_HOST_MEMORY => return error.VK_OUT_OF_HOST_MEMORY,
		.ERROR_OUT_OF_DEVICE_MEMORY => return error.VK_OUT_OF_DEVICE_MEMORY,
		.ERROR_INITIALIZATION_FAILED => return error.VK_INITIALIZATION_FAILED,
		.ERROR_DEVICE_LOST => return error.VK_DEVICE_LOST,
		.ERROR_MEMORY_MAP_FAILED => return error.VK_MEMORY_MAP_FAILED,
		.ERROR_LAYER_NOT_PRESENT => return error.VK_LAYER_NOT_PRESENT,
		.ERROR_EXTENSION_NOT_PRESENT => return error.VK_EXTENSION_NOT_PRESENT,
		.ERROR_FEATURE_NOT_PRESENT => return error.VK_FEATURE_NOT_PRESENT,
		.ERROR_INCOMPATIBLE_DRIVER => return error.VK_INCOMPATIBLE_DRIVER,
		.ERROR_TOO_MANY_OBJECTS => return error.VK_TOO_MANY_OBJECTS,
		.ERROR_FORMAT_NOT_SUPPORTED => return error.VK_FORMAT_NOT_SUPPORTED,
		.ERROR_FRAGMENTED_POOL => return error.VK_FRAGMENTED_POOL,
		.ERROR_OUT_OF_POOL_MEMORY => return error.VK_OUT_OF_POOL_MEMORY,
		.ERROR_INVALID_EXTERNAL_HANDLE => return error.VK_INVALID_EXTERNAL_HANDLE,
		.ERROR_SURFACE_LOST_KHR => return error.VK_SURFACE_LOST_KHR,
		.ERROR_NATIVE_WINDOW_IN_USE_KHR => return error.VK_NATIVE_WINDOW_IN_USE_KHR,
		.SUBOPTIMAL_KHR => return error.VK_SUBOPTIMAL_KHR,
		.ERROR_OUT_OF_DATE_KHR => return error.VK_OUT_OF_DATE_KHR,
		.ERROR_INCOMPATIBLE_DISPLAY_KHR => return error.VK_INCOMPATIBLE_DISPLAY_KHR,
		.ERROR_VALIDATION_FAILED_EXT => return error.VK_VALIDATION_FAILED_EXT,
		.ERROR_INVALID_SHADER_NV => return error.VK_INVALID_SHADER_NV,
		.ERROR_FRAGMENTATION_EXT = return error.VK_FRAGMENTATION_EXT,
		.ERROR_NOT_PERMITTED_EXT = return error.VK_NOT_PERMITTED_EXT,
		else => return error.VK_UNKNOWN_ERROR,
	}
}

pub extern fn vkCreateInstance(pCreateInfo: *const InstanceCreateInfo, pAllocator: ?*const AllocationCallbacks, pInstance: *Instance) Result;
pub fn CreateInstance(pCreateInfo: *const InstanceCreateInfo, pAllocator: ?*const AllocationCallbacks) !Instance {
	var inst: Instance = undefined;
	const result = vkCreateInstance(pCreateInfo, pAllocator, &inst);
	if (result == .SUCCESS) return inst;
	try mapError(result);
}

pub extern fn vkDestroyInstance(instance: Instance, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyInstance = vkDestroyInstance;

pub extern fn vkEnumeratePhysicalDevices(instance: Instance, pPhysicalDeviceCount: *u32, pPhysicalDevices: ?[*]PhysicalDevice) Result;
pub fn EnumeratePhysicalDevicesNum(instance: Instance) !u32 {
	var numPhysicalDevices = u32(0);
	const result = vkEnumeratePhysicalDevices(instance, &numPhysicalDevices, null);
	if (result == .SUCCESS or result == .INCOMPLETE) return numPhysicalDevices
	try mapError(result);
}
pub fn EnumeratePhysicalDevicesBuffered(instance: Instance, devicesBuffer: []PhysicalDevice) ![]PhysicalDevice {
	var numPhysicalDevices = @intCast(u32, devicesBuffer.len);
	const result = vkEnumeratePhysicalDevices(instance, &numPhysicalDevices, devicesBuffer.ptr);
	if (result == .SUCCESS or result == .INCOMPLETE) return devicesBuffer[0..numPhysicalDevices];
	try mapError(result);
}
pub fn EnumeratePhysicalDevices(instance: Instance, allocator: *Allocator) ![]PhysicalDevice {
	const count = try EnumeratePhysicalDevicesNum(instance);
	const buffer = try allocator.alloc(PhysicalDevice, count);
	errdefer allocator.free(buffer);
	return try EnumeratePhysicalDevicesBuffered(instance, buffer);
}

pub extern fn vkGetPhysicalDeviceFeatures(physicalDevice: PhysicalDevice, pFeatures: *PhysicalDeviceFeatures) void;
pub fn GetPhysicalDeviceFeatures(physicalDevice: PhysicalDevice) PhysicalDeviceFeatures {
	var features: PhysicalDeviceFeatures = undefined;
	vkGetPhysicalDeviceFeatures(physicalDevice, &features);
	return features;
}

pub extern fn vkGetPhysicalDeviceFormatProperties(physicalDevice: PhysicalDevice, format: Format, pFormatProperties: *FormatProperties) void;
pub fn GetPhysicalDeviceFormatProperties(physicalDevice: PhysicalDevice, format: Format) FormatProperties {
	var props: FormatProperties = undefined;
	vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &props);
	return props;
}

pub extern fn vkGetPhysicalDeviceImageFormatProperties(physicalDevice: PhysicalDevice, format: Format, imageType: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags, pImageFormatProperties: *ImageFormatProperties) Result;
pub fn GetPhysicalDeviceImageFormatProperties(physicalDevice: PhysicalDevice, format: Format, imageType: ImageType, tiling: ImageTiling, usage: ImageUsageFlags, flags: ImageCreateFlags) !ImageFormatProperties {
	var props: ImageFormatProperties = undefined;
	const result = vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, imageType, tiling, usage, flags, &props);
	if (result == .SUCCESS) return props;
	try mapError(result);
}

pub extern fn vkGetPhysicalDeviceProperties(physicalDevice: PhysicalDevice, pProperties: *PhysicalDeviceProperties) void;
pub fn GetPhysicalDeviceProperties(physicalDevice: PhysicalDevice) PhysicalDeviceProperties {
	var props: PhysicalDeviceProperties = undefined;
	vkGetPhysicalDeviceProperties(physicalDevice, &props);
	return props;
}

pub extern fn vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice: PhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: ?[*]QueueFamilyProperties) void;
pub fn GetPhysicalDeviceQueueFamilyPropertiesNum(physicalDevice: PhysicalDevice) !u32 {
	var numProperties = u32(0);
	const result = vkEnumeratePhysicalDevices(instance, &numProperties, null);
	if (result == .SUCCESS or result == .INCOMPLETE) return numProperties;
	try mapError(result);
}
pub fn GetPhysicalDeviceQueueFamilyPropertiesBuffered(physicalDevice: PhysicalDevice, propertyBuffer: []QueueFamilyProperties) ![]QueueFamilyProperties {
	var numProperties = @intCast(u32, propertyBuffer.len);
	const result = vkEnumeratePhysicalDevices(instance, &numProperties, propertyBuffer.ptr);
	if (result == .SUCCESS or result == .INCOMPLETE) return propertyBuffer[0..numProperties];
	try mapError(result);
}
pub fn GetPhysicalDeviceQueueFamilyProperties(physicalDevice: PhysicalDevice, allocator: *Allocator) ![]QueueFamilyProperties {
	const count = try GetPhysicalDeviceQueueFamilyPropertiesNum(physicalDevice);
	const buffer = try allocator.alloc(QueueFamilyProperties, count);
	errdefer allocator.free(buffer);
	return try GetPhysicalDeviceQueueFamilyPropertiesBuffered(physicalDevice, buffer);
}

pub extern fn vkGetPhysicalDeviceMemoryProperties(physicalDevice: PhysicalDevice, pMemoryProperties: *PhysicalDeviceMemoryProperties) void;
pub fn GetPhysicalDeviceMemoryProperties(physicalDevice: PhysicalDevice) PhysicalDeviceMemoryProperties {
	var props: PhysicalDeviceMemoryProperties = undefined;
	vkGetPhysicalDeviceMemoryProperties(physicalDevice, &props);
	return props;
}

pub extern fn vkGetInstanceProcAddr(instance: Instance, pName: CString) VoidFunction;
pub const GetInstanceProcAddr = vkGetInstanceProcAddr;

pub extern fn vkGetDeviceProcAddr(device: Device, pName: CString) VoidFunction;
pub const GetDeviceProcAddr = vkGetDeviceProcAddr;

pub extern fn vkCreateDevice(physicalDevice: PhysicalDevice, pCreateInfo: *const DeviceCreateInfo, pAllocator: ?*const AllocationCallbacks, pDevice: *Device) Result;
pub fn CreateDevice(physicalDevice: PhysicalDevice, pCreateInfo: *const DeviceCreateInfo, pAllocator: ?*const AllocationCallbacks) !Device {
	var device: Device = null;
	const result = vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, &device);
	if (result == .SUCCESS) return device;
	try mapError(result);
}

pub extern fn vkDestroyDevice(device: Device, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyDevice = vkDestroyDevice;

pub extern fn vkEnumerateInstanceExtensionProperties(pLayerName: ?CString, pPropertyCount: *u32, pProperties: ?[*]ExtensionProperties) Result;
pub fn EnumerateInstanceExtensionPropertiesNum(pLayerName: ?CString) !u32 {
	var numProperties = u32(0);
	const result = vkEnumerateInstanceExtensionProperties(pLayerName, &numProperties, null);
	if (result == .SUCCESS or result == .INCOMPLETE) return numProperties;
	try mapError(result);
}
pub fn EnumerateInstanceExtensionPropertiesBuffered(pLayerName: ?CString, propertyBuffer: []ExtensionProperties) ![]ExtensionProperties {
	var numProperties = @intCast(u32, propertyBuffer.len);
	const result = vkEnumerateInstanceExtensionProperties(pLayerName, &numProperties, propertyBuffer.ptr);
	if (result == .SUCCESS or result == .INCOMPLETE) return propertyBuffer[0..numProperties];
	try mapError(result);
}
pub fn EnumerateInstanceExtensionProperties(pLayerName: ?CString, allocator: *Allocator) ![]ExtensionProperties {
	const count = try EnumerateInstanceExtensionPropertiesNum(pLayerName);
	const buffer = try allocator.alloc(ExtensionProperties, count);
	errdefer allocator.free(buffer);
	return try EnumerateInstanceExtensionPropertiesBuffered(pLayerName, buffer);
}

pub extern fn vkEnumerateDeviceExtensionProperties(physicalDevice: PhysicalDevice, pLayerName: ?CString, pPropertyCount: *u32, pProperties: ?[*]ExtensionProperties) Result;
pub fn EnumerateDeviceExtensionPropertiesNum(physicalDevice: PhysicalDevice, pLayerName: ?CString) !u32 {
	var numProperties = u32(0);
	const result = vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, &numProperties, null);
	if (result == .SUCCESS or result == .INCOMPLETE) return numProperties;
	try mapError(result);
}
pub fn EnumerateDeviceExtensionPropertiesBuffered(physicalDevice: PhysicalDevice, pLayerName: ?CString, propertyBuffer: []ExtensionProperties) ![]ExtensionProperties {
	var numProperties = @intCast(u32, propertyBuffer.len);
	const result = vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, &numProperties, propertyBuffer.ptr);
	if (result == .SUCCESS or result == .INCOMPLETE) return propertyBuffer[0..numProperties];
	try mapError(result);
}
pub fn EnumerateDeviceExtensionProperties(physicalDevice: PhysicalDevice, pLayerName: ?CString, allocator: *Allocator) ![]ExtensionProperties {
	const count = try EnumerateDeviceExtensionPropertiesNum(physicalDevice, pLayerName);
	const buffer = try allocator.alloc(ExtensionProperties, count);
	errdefer allocator.free(buffer);
	return try EnumerateDeviceExtensionPropertiesBuffered(physicalDevice, pLayerName, buffer);
}

pub extern fn vkEnumerateInstanceLayerProperties(pPropertyCount: *u32, pProperties: ?[*]LayerProperties) Result;
pub fn EnumerateInstanceLayerPropertiesNum() !u32 {
	var numProperties = u32(0);
	const result = vkEnumerateInstanceLayerProperties(&numProperties, null);
	if (result == .SUCCESS or result == .INCOMPLETE) return numProperties;
	try mapError(result);
}
pub fn EnumerateInstanceLayerPropertiesBuffered(propertyBuffer: []LayerProperties) ![]LayerProperties {
	var numProperties = @intCast(u32, propertyBuffer.len);
	const result = vkEnumerateInstanceLayerProperties(&numProperties, propertyBuffer.ptr);
	if (result == .SUCCESS or result == .INCOMPLETE) return propertyBuffer[0..numProperties];
	try mapError(result);
}
pub fn EnumerateInstanceLayerProperties(allocator: *Allocator) ![]LayerProperties {
	const count = try EnumerateInstanceLayerPropertiesNum();
	const buffer = try allocator.alloc(LayerProperties, count);
	errdefer allocator.free(buffer);
	return try EnumerateInstanceLayerPropertiesBuffered(buffer);
}

pub extern fn vkEnumerateDeviceLayerProperties(physicalDevice: PhysicalDevice, pPropertyCount: *u32, pProperties: ?[*]LayerProperties) Result;
pub fn EnumerateDeviceLayerPropertiesNum(physicalDevice: PhysicalDevice) !u32 {
	var numProperties = u32(0);
	const result = vkEnumerateDeviceLayerProperties(physicalDevice, &numProperties, null);
	if (result == .SUCCESS or result == .INCOMPLETE) return numProperties;
	try mapError(result);
}
pub fn EnumerateDeviceLayerPropertiesBuffered(physicalDevice: PhysicalDevice, propertyBuffer: []LayerProperties) ![]LayerProperties {
	var numProperties = @intCast(u32, propertyBuffer.len);
	const result = vkEnumerateDeviceLayerProperties(physicalDevice, &numProperties, propertyBuffer.ptr);
	if (result == .SUCCESS or result == .INCOMPLETE) return propertyBuffer[0..numProperties];
	try mapError(result);
}
pub fn EnumerateDeviceLayerProperties(physicalDevice: PhysicalDevice, allocator: *Allocator) ![]LayerProperties {
	const count = try EnumerateDeviceLayerPropertiesNum(physicalDevice);
	const buffer = try allocator.alloc(LayerProperties, count);
	errdefer allocator.free(buffer);
	return try EnumerateDeviceLayerPropertiesBuffered(physicalDevice, buffer);
}

pub extern fn vkGetDeviceQueue(device: Device, queueFamilyIndex: u32, queueIndex: u32, pQueue: *Queue) void;
pub fn GetDeviceQueue(device: Device, queueFamilyIndex: u32, queueIndex: u32) Queue {
	var queue: Queue = null;
	vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, &queue);
	return queue;
}

pub extern fn vkQueueSubmit(queue: Queue, submitCount: u32, pSubmits: ?[*]const SubmitInfo, fence: Fence) Result;
pub fn QueueSubmit(queue: Queue, submits: []const SubmitInfo, fence: Fence) !void {
	const result = vkQueueSubmit(queue, @intCast(u32, submits.len), submits.ptr, fence);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkQueueWaitIdle(queue: Queue) Result;
pub fn QueueWaitIdle(queue: Queue) !void {
	const result = vkQueueWaitIdle(queue);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkDeviceWaitIdle(device: Device) Result;
pub fn DeviceWaitIdle(device: Device) !void {
	const result = vkDeviceWaitIdle(device);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkAllocateMemory(device: Device, pAllocateInfo: *const MemoryAllocateInfo, pAllocator: ?*const AllocationCallbacks, pMemory: *DeviceMemory) Result;
pub fn AllocateMemory(device: Device, pAllocateInfo: *const MemoryAllocateInfo, pAllocator: ?*const AllocationCallbacks) !DeviceMemory {
	var mem: DeviceMemory = null;
	const result = vkAllocateMemory(device, pAllocateInfo, pAllocator, &mem);
	if (result == .SUCCESS) return mem;
	try mapError(result);
}

pub extern fn vkFreeMemory(device: Device, memory: DeviceMemory, pAllocator: ?*const AllocationCallbacks) void;
pub const FreeMemory = vkFreeMemory;

pub extern fn vkMapMemory(device: Device, memory: DeviceMemory, offset: DeviceSize, size: DeviceSize, flags: MemoryMapFlags, ppData: *(?*c_void)) Result;
pub fn MapMemory(comptime MappedDataType: type, device: Device, memory: DeviceMemory, offset: DeviceSize, size: DeviceSize, flags: MemoryMapFlags) ![]MappedDataType {
	var mappedMem: ?[*]MappedDataType = null;
	const ppData = @ptrCast(*(?*c_void), &mappedMem);
	const result = vkMapMemory(device, memory, offset, size, flags, ppData);
	if (result == .SUCCESS) return mappedMem[0..size/@sizeOf(MappedDataType)];
	try mapError(result);
}

pub extern fn vkUnmapMemory(device: Device, memory: DeviceMemory) void;
pub const UnmapMemory = vkUnmapMemory;

pub extern fn vkFlushMappedMemoryRanges(device: Device, memoryRangeCount: u32, pMemoryRanges: ?[*]const MappedMemoryRange) Result;
pub fn FlushMappedMemoryRanges(device: Device, memoryRanges: []const MappedMemoryRange) !void {
	const result = vkFlushMappedMemoryRanges(device, @intCast(u32, memoryRanges.len), memoryRanges.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkInvalidateMappedMemoryRanges(device: Device, memoryRangeCount: u32, pMemoryRanges: ?[*]const MappedMemoryRange) Result;
pub fn InvalidateMappedMemoryRanges(device: Device, memoryRanges: []const MappedMemoryRange) !void {
	const result = vkInvalidateMappedMemoryRanges(device, @intCast(u32, memoryRanges.len), memoryRanges.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkGetDeviceMemoryCommitment(device: Device, memory: DeviceMemory, pCommittedMemoryInBytes: *DeviceSize) void;
pub fn GetDeviceMemoryCommitment(device: Device, memory: DeviceMemory) DeviceSize {
	var size: DeviceSize = 0;
	vkGetDeviceMemoryCommitment(device, memory, &size);
	return size;
}

pub extern fn vkBindBufferMemory(device: Device, buffer: Buffer, memory: DeviceMemory, memoryOffset: DeviceSize) Result;
pub fn BindBufferMemory(device: Device, buffer: Buffer, memory: DeviceMemory, memoryOffset: DeviceSize) !void {
	const result = vkBindBufferMemory(device, buffer, memory, memoryOffset);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkBindImageMemory(device: Device, image: Image, memory: DeviceMemory, memoryOffset: DeviceSize) Result;
pub fn BindImageMemory(device: Device, image: Image, memory: DeviceMemory, memoryOffset: DeviceSize) !void {
	const result = vkBindImageMemory(device, image, memory, memoryOffset);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkGetBufferMemoryRequirements(device: Device, buffer: Buffer, pMemoryRequirements: *MemoryRequirements) void;
pub fn GetBufferMemoryRequirements(device: Device, buffer: Buffer) MemoryRequirements {
	var reqs: MemoryRequirements = undefined;
	vkGetBufferMemoryRequirements(device, buffer, &reqs);
	return reqs;
}

pub extern fn vkGetImageMemoryRequirements(device: Device, image: Image, pMemoryRequirements: *MemoryRequirements) void;
pub fn GetImageMemoryRequirements(device: Device, image: Image) MemoryRequirements {
	var reqs: MemoryRequirements = undefined;
	vkGetImageMemoryRequirements(device, buffer, &reqs);
	return reqs;
}

pub extern fn vkGetImageSparseMemoryRequirements(device: Device, image: Image, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: ?[*]SparseImageMemoryRequirements) void;
pub fn GetImageSparseMemoryRequirementsNum(device: Device, image: Image) u32 {
	var count = u32(0);
	vkGetImageSparseMemoryRequirements(device, image, &count, null);
	return count;
}
pub fn GetImageSparseMemoryRequirementsBuffered(device: Device, image: Image, buffer: []SparseImageMemoryRequirements) []SparseImageMemoryRequirements {
	var count = @intCast(u32, buffer.len);
	vkGetImageSparseMemoryRequirements(device, image, &count, buffer.ptr);
	return buffer[0..count];
}
pub fn GetImageSparseMemoryRequirements(device: Device, image: Image, allocator: *Allocator) ![]SparseImageMemoryRequirements {
	var count = GetImageSparseMemoryRequirementsNum(device, image);
	var buffer = try allocator.alloc(SparseImageMemoryRequirements, count);
	errdefer allocator.free(buffer);
	return GetImageSparseMemoryRequirementsBuffered(device, image, buffer);
}

pub extern fn vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice: PhysicalDevice, format: Format, imageType: ImageType, samples: SampleCountFlags, usage: ImageUsageFlags, tiling: ImageTiling, pPropertyCount: *u32, pProperties: ?[*]SparseImageFormatProperties) void;
pub fn GetPhysicalDeviceSparseImageFormatPropertiesNum(physicalDevice: PhysicalDevice, format: Format, imageType: ImageType, samples: SampleCountFlags, usage: ImageUsageFlags, tiling: ImageTiling) u32 {
	var count = u32(0);
	vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, imageType, samples, usage, tiling, &count, null);
	return count;
}
pub fn GetPhysicalDeviceSparseImageFormatPropertiesBuffered(physicalDevice: PhysicalDevice, format: Format, imageType: ImageType, samples: SampleCountFlags, usage: ImageUsageFlags, tiling: ImageTiling, buffer: []SparseImageFormatProperties) []SparseImageFormatProperties {
	var count = @intCast(u32, buffer.len);
	vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, imageType, samples, usage, tiling, &count, buffer.ptr);
	return buffer[0..count];
}
pub fn GetPhysicalDeviceSparseImageFormatProperties(physicalDevice: PhysicalDevice, format: Format, imageType: ImageType, samples: SampleCountFlags, usage: ImageUsageFlags, tiling: ImageTiling, allocator: *Allocator) ![]SparseImageFormatProperties {
	var count = GetImageSparseMemoryRequirementsNum(physicalDevice, format, imageType, samples, usage, tiling);
	var buffer = try allocator.alloc(SparseImageFormatProperties, count);
	errdefer allocator.free(buffer);
	return GetImageSparseMemoryRequirementsBuffered(physicalDevice, format, imageType, samples, usage, tiling, buffer);
}

pub extern fn vkQueueBindSparse(queue: Queue, bindInfoCount: u32, pBindInfo: ?[*]const BindSparseInfo, fence: Fence) Result;
pub fn QueueBindSparse(queue: Queue, bindInfo: []const BindSparseInfo, fence: Fence) !void {
	const result = vkQueueBindSparse(queue, @intCast(u32, bindInfo.len), bindInfo.ptr, fence);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkCreateFence(device: Device, pCreateInfo: *const FenceCreateInfo, pAllocator: ?*const AllocationCallbacks, pFence: *Fence) Result;
pub fn CreateFence(device: Device, pCreateInfo: *const FenceCreateInfo, pAllocator: ?*const AllocationCallbacks) !Fence {
	var fence: Fence = null;
	const result = vkCreateFence(device, pCreateInfo, pAllocator, &fence);
	if (result == .SUCCESS) return fence;
	try mapError(result);
}

pub extern fn vkDestroyFence(device: Device, fence: Fence, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyFence = vkDestroyFence;

pub extern fn vkResetFences(device: Device, fenceCount: u32, pFences: [*]const Fence) Result;
pub fn ResetFences(device: Device, fences: []const Fence) !void {
	const result = vkResetFences(device, @intCast(u32, fences.len), fences.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkGetFenceStatus(device: Device, fence: Fence) Result;
pub fn GetFenceStatus(device: Device, fence: Fence) !Result {
	const result = vkGetFenceStatus(device, fence);
	if (@enumToInt(i32, result) >= 0) return result;
	try mapError(result);
}

pub extern fn vkWaitForFences(device: Device, fenceCount: u32, pFences: ?[*]const Fence, waitAll: Bool32, timeout: u64) Result;
pub fn WaitForFences(device: Device, fences: []const Fence, waitAll: bool, timeout: u64) !void {
	const result = vkWaitForFences(device, @intCast(u32, fences.len), fences.ptr, @boolToInt(waitAll), timeout);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkCreateSemaphore(device: Device, pCreateInfo: *const SemaphoreCreateInfo, pAllocator: ?*const AllocationCallbacks, pSemaphore: *Semaphore) Result;
pub fn CreateSemaphore(device: Device, pCreateInfo: *const SemaphoreCreateInfo, pAllocator: ?*const AllocationCallbacks) !Semaphore {
	var sem: Semaphore = null;
	const result = vkCreateSemaphore(device, pCreateInfo, pAllocator, &sem);
	if (result == .SUCCESS) return sem;
	try mapError(result);
}

pub extern fn vkDestroySemaphore(device: Device, semaphore: Semaphore, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroySemaphore = vkDestroySemaphore;

pub extern fn vkCreateEvent(device: Device, pCreateInfo: *const EventCreateInfo, pAllocator: ?*const AllocationCallbacks, pEvent: *Event) Result;
pub fn CreateEvent(device: Device, pCreateInfo: *const EventCreateInfo, pAllocator: ?*const AllocationCallbacks) !Event {
	var evt: Event = null;
	const result = vkCreateEvent(device, pCreateInfo, pAllocator, &evt);
	if (result == .SUCCESS) return evt;
	try mapError(result);
}

pub extern fn vkDestroyEvent(device: Device, event: Event, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyEvent = vkDestroyEvent;

pub extern fn vkGetEventStatus(device: Device, event: Event) Result;
pub fn GetEventStatus(device: Device, event: Event) !Result {
	const result = vkGetEventStatus(device, event);
	if (@enumToInt(i32, result) >= 0) return result;
	try mapError(result);
}

pub extern fn vkSetEvent(device: Device, event: Event) Result;
pub fn SetEvent(device: Device, event: Event) !void {
	const result = vkSetEvent(device, event);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkResetEvent(device: Device, event: Event) Result;
pub fn ResetEvent(device: Device, event: Event) !void {
	const result = vkResetEvent(device, event);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkCreateQueryPool(device: Device, pCreateInfo: *const QueryPoolCreateInfo, pAllocator: ?*const AllocationCallbacks, pQueryPool: *QueryPool) Result;
pub fn CreateQueryPool(device: Device, pCreateInfo: *const QueryPoolCreateInfo, pAllocator: ?*const AllocationCallbacks) !QueryPool {
	var pool: QueryPool = null;
	const result = vkCreateQueryPool(device, pCreateInfo, pAllocator, &pool);
	if (result == .SUCCESS) return pool;
	try mapError(result);
}

pub extern fn vkDestroyQueryPool(device: Device, queryPool: QueryPool, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyQueryPool = vkDestroyQueryPool;

pub extern fn vkGetQueryPoolResults(device: Device, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: ?*c_void, stride: DeviceSize, flags: QueryResultFlags) Result;
// @TODO: Figure out how to properly wrap this func once you have usage examples

pub extern fn vkCreateBuffer(device: Device, pCreateInfo: *const BufferCreateInfo, pAllocator: ?*const AllocationCallbacks, pBuffer: *Buffer) Result;
pub fn CreateBuffer(device: Device, pCreateInfo: *const BufferCreateInfo, pAllocator: ?*const AllocationCallbacks) !Buffer {
	var buf: Buffer = null;
	const result = vkCreateBuffer(device, pCreateInfo, pAllocator, &buf);
	if (result == .SUCCESS) return buf;
	try mapError(result);
}

pub extern fn vkDestroyBuffer(device: Device, buffer: Buffer, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyBuffer = vkDestroyBuffer;

pub extern fn vkCreateBufferView(device: Device, pCreateInfo: *const BufferViewCreateInfo, pAllocator: ?*const AllocationCallbacks, pView: *BufferView) Result;
pub fn CreateBufferView(device: Device, pCreateInfo: *const BufferViewCreateInfo, pAllocator: ?*const AllocationCallbacks) !BufferView {
	var buf: BufferView = null;
	const result = vkCreateBufferView(device, pCreateInfo, pAllocator, &buf);
	if (result == .SUCCESS) return buf;
	try mapError(result);
}

pub extern fn vkDestroyBufferView(device: Device, bufferView: BufferView, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyBufferView = vkDestroyBufferView;

pub extern fn vkCreateImage(device: Device, pCreateInfo: *const ImageCreateInfo, pAllocator: ?*const AllocationCallbacks, pImage: *Image) Result;
pub fn CreateImage(device: Device, pCreateInfo: *const ImageCreateInfo, pAllocator: ?*const AllocationCallbacks) !Image {
	var image: Image = null;
	const result = vkCreateImage(device, pCreateInfo, pAllocator, &image);
	if (result == .SUCCESS) return image;
	try mapError(result);
}

pub extern fn vkDestroyImage(device: Device, image: Image, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyImage = vkDestroyImage;

pub extern fn vkGetImageSubresourceLayout(device: Device, image: Image, pSubresource: *const ImageSubresource, pLayout: *SubresourceLayout) void;
pub fn GetImageSubresourceLayout(device: Device, image: Image, pSubresource: *const ImageSubresource) SubresourceLayout {
	var layout: SubresourceLayout = undefined;
	vkGetImageSubresourceLayout(device, image, pSubresource, &layout);
	return layout;
}

pub extern fn vkCreateImageView(device: Device, pCreateInfo: *const ImageViewCreateInfo, pAllocator: ?*const AllocationCallbacks, pView: *ImageView) Result;
pub fn CreateImageView(device: Device, pCreateInfo: *const ImageViewCreateInfo, pAllocator: ?*const AllocationCallbacks) !ImageView {
	var view: ImageView = null;
	const result = vkCreateImageView(device, pCreateInfo, pAllocator, &view);
	if (result == .SUCCESS) return view;
	try mapError(result);
}

pub extern fn vkDestroyImageView(device: Device, imageView: ImageView, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyImageView = vkDestroyImageView;

pub extern fn vkCreateShaderModule(device: Device, pCreateInfo: *const ShaderModuleCreateInfo, pAllocator: ?*const AllocationCallbacks, pShaderModule: *ShaderModule) Result;
pub fn CreateShaderModule(device: Device, pCreateInfo: *const ShaderModuleCreateInfo, pAllocator: ?*const AllocationCallbacks) !ShaderModule {
	var module: ShaderModule = null;
	const result = vkCreateShaderModule(device, pCreateInfo, pAllocator, &module);
	if (result == .SUCCESS) return module;
	try mapError(result);
}

pub extern fn vkDestroyShaderModule(device: Device, shaderModule: ShaderModule, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyShaderModule = vkDestroyShaderModule;

pub extern fn vkCreatePipelineCache(device: Device, pCreateInfo: *const PipelineCacheCreateInfo, pAllocator: ?*const AllocationCallbacks, pPipelineCache: *PipelineCache) Result;
pub fn CreatePipelineCache(device: Device, pCreateInfo: *const PipelineCacheCreateInfo, pAllocator: ?*const AllocationCallbacks) !PipelineCache {
	var cache: PipelineCache = null;
	const result = vkCreatePipelineCache(device, pCreateInfo, pAllocator, &cache);
	if (result == .SUCCESS) return cache;
	try mapError(result);
}

pub extern fn vkDestroyPipelineCache(device: Device, pipelineCache: PipelineCache, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyPipelineCache = vkDestroyPipelineCache;

pub extern fn vkGetPipelineCacheData(device: Device, pipelineCache: PipelineCache, pDataSize: ?[*]usize, pData: ?*c_void) Result;
// @TODO Write a binding for this

pub extern fn vkMergePipelineCaches(device: Device, dstCache: PipelineCache, srcCacheCount: u32, pSrcCaches: ?[*]const PipelineCache) Result;
pub fn MergePipelineCaches(device: Device, dstCache: PipelineCache, srcCaches: []PipelineCache) !void {
	const result = vkMergePipelineCaches(device, dstCache, @intCast(u32, srcCaches.len), srcCaches.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkCreateGraphicsPipelines(device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: [*]const GraphicsPipelineCreateInfo, pAllocator: ?*const AllocationCallbacks, pPipelines: [*]Pipeline) Result;
pub fn CreateGraphicsPipelines(device: Device, pipelineCache: PipelineCache, createInfos: []const GraphicsPipelineCreateInfo, pAllocator: ?*const AllocationCallbacks, outPipelines: []Pipeline) !void {
	std.debug.assert(outPipelines.len >= createInfos.len);
	const result = vkCreateGraphicsPipelines(device, pipelineCache, @intCast(u32, createInfos.len), createInfos.ptr, pAllocator, outPipelines.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}
pub fn CreateGraphicsPipeline(device: Device, pipelineCache: PipelineCache, createInfo: *const GraphicsPipelineCreateInfo, pAllocator: ?*const AllocationCallbacks) !Pipeline {
	var pipelines = [_]Pipeline{ null };
	const result = vkCreateGraphicsPipelines(device, pipelineCache, 1, @ptrCast([*]const GraphicsPipelineCreateInfo, createInfo), pAllocator, &pipelines);
	if (result == .SUCCESS) return pipelines[0];
	try mapError(result);
}

pub extern fn vkCreateComputePipelines(device: Device, pipelineCache: PipelineCache, createInfoCount: u32, pCreateInfos: [*]const ComputePipelineCreateInfo, pAllocator: ?*const AllocationCallbacks, pPipelines: [*]Pipeline) Result;
pub fn CreateComputePipelines(device: Device, pipelineCache: PipelineCache, createInfos: []const ComputePipelineCreateInfo, pAllocator: ?*const AllocationCallbacks, outPipelines: []Pipeline) !void {
	std.debug.assert(outPipelines.len >= createInfos.len);
	const result = vkCreateComputePipelines(device, pipelineCache, @intCast(u32, createInfos.len), createInfos.ptr, pAllocator, outPipelines.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}
pub fn CreateComputePipeline(device: Device, pipelineCache: PipelineCache, createInfo: *const ComputePipelineCreateInfo, pAllocator: ?*const AllocationCallbacks) !Pipeline {
	var pipelines = [_]Pipeline{ null };
	const result = vkCreateComputePipelines(device, pipelineCache, 1, @ptrCast([*]const ComputePipelineCreateInfo, createInfo), pAllocator, &pipelines);
	if (result == .SUCCESS) return pipelines[0];
	try mapError(result);
}

pub extern fn vkDestroyPipeline(device: Device, pipeline: Pipeline, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyPipeline = vkDestroyPipeline;

pub extern fn vkCreatePipelineLayout(device: Device, pCreateInfo: *const PipelineLayoutCreateInfo, pAllocator: ?*const AllocationCallbacks, pPipelineLayout: *PipelineLayout) Result;
pub fn CreatePipelineLayout(device: Device, pCreateInfo: *const PipelineLayoutCreateInfo, pAllocator: ?*const AllocationCallbacks) !PipelineLayout {
	var layout: PipelineLayout = null;
	const result = vkCreatePipelineLayout(device, pCreateInfo, pAllocator, &layout);
	if (result == .SUCCESS) return layout;
	try mapError(result);
}

pub extern fn vkDestroyPipelineLayout(device: Device, pipelineLayout: PipelineLayout, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyPipelineLayout = vkDestroyPipelineLayout;

pub extern fn vkCreateSampler(device: Device, pCreateInfo: *const SamplerCreateInfo, pAllocator: ?*const AllocationCallbacks, pSampler: *Sampler) Result;
pub fn CreateSampler(device: Device, pCreateInfo: *const SamplerCreateInfo, pAllocator: ?*const AllocationCallbacks) !Sampler {
	var sampler: Sampler = null;
	const result = vkCreateSampler(device, pCreateInfo, pAllocator, &sampler);
	if (result == .SUCCESS) return sampler;
	try mapError(result);
}

pub extern fn vkDestroySampler(device: Device, sampler: Sampler, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroySampler = vkDestroySampler;

pub extern fn vkCreateDescriptorSetLayout(device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pAllocator: ?*const AllocationCallbacks, pSetLayout: *DescriptorSetLayout) Result;
pub fn CreateDescriptorSetLayout(device: Device, pCreateInfo: *const DescriptorSetLayoutCreateInfo, pAllocator: ?*const AllocationCallbacks) !DescriptorSetLayout {
	var layout: DescriptorSetLayout = null;
	const result = vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, &layout);
	if (result == .SUCCESS) return layout;
	try mapError(result);
}

pub extern fn vkDestroyDescriptorSetLayout(device: Device, descriptorSetLayout: DescriptorSetLayout, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyDescriptorSetLayout = vkDestroyDescriptorSetLayout;

pub extern fn vkCreateDescriptorPool(device: Device, pCreateInfo: *const DescriptorPoolCreateInfo, pAllocator: ?*const AllocationCallbacks, pDescriptorPool: *DescriptorPool) Result;
pub fn CreateDescriptorPool(device: Device, pCreateInfo: *const DescriptorPoolCreateInfo, pAllocator: ?*const AllocationCallbacks) !DescriptorPool {
	var pool: DescriptorPool = null;
	const result = vkCreateDescriptorPool(device, pCreateInfo, pAllocator, &pool);
	if (result == .SUCCESS) return pool;
	try mapError(result);
} 

pub extern fn vkDestroyDescriptorPool(device: Device, descriptorPool: DescriptorPool, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyDescriptorPool = vkDestroyDescriptorPool;

pub extern fn vkResetDescriptorPool(device: Device, descriptorPool: DescriptorPool, flags: DescriptorPoolResetFlags) Result;
pub fn ResetDescriptorPool(device: Device, descriptorPool: DescriptorPool, flags: DescriptorPoolResetFlags) !void {
	const result = vkResetDescriptorPool(device, descriptorPool, flags);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkAllocateDescriptorSets(device: Device, pAllocateInfo: *const DescriptorSetAllocateInfo, pDescriptorSets: ?[*]DescriptorSet) Result;
pub fn AllocateDescriptorSets(device: Device, pAllocateInfo: *const DescriptorSetAllocateInfo, descriptorSets: []DescriptorSet) !void {
	std.debug.assert(descriptorSets.len >= pAllocateInfo.descriptorSetCount);
	const result = vkAllocateDescriptorSets(device, pAllocateInfo, descriptorSets.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}
pub fn AllocateDescriptorSet(device: Device, pAllocateInfo: *const DescriptorSetAllocateInfo) !DescriptorSet {
	std.debug.assert(pAllocateInfo.descriptorSetCount == 1);
	var sets = [_]DescriptorSet{ null };
	const result = vkAllocateDescriptorSets(device, pAllocateInfo, &sets);
	if (result == .SUCCESS) return sets[0];
	try mapError(result);
}

pub extern fn vkFreeDescriptorSets(device: Device, descriptorPool: DescriptorPool, descriptorSetCount: u32, pDescriptorSets: ?[*]const DescriptorSet) Result;
pub fn FreeDescriptorSets(device: Device, descriptorPool: DescriptorPool, descriptorSets: []const DescriptorSet) !void {
	const result = vkFreeDescriptorSets(device, descriptorPool, @intCast(u32, descriptorSets.len), descriptorSets.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkUpdateDescriptorSets(device: Device, descriptorWriteCount: u32, pDescriptorWrites: ?[*]const WriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: ?[*]const CopyDescriptorSet) void;
pub fn UpdateDescriptorSets(device: Device, descriptorWrites: []const WriteDescriptorSet, descriptorCopies: []const CopyDescriptorSet) void {
	vkUpdateDescriptorSets(device, @intCast(u32, descriptorWrites.len), descriptorWrites.ptr, @intCast(u32, descriptorCopies.len), descriptorCopies.ptr);
}

pub extern fn vkCreateFramebuffer(device: Device, pCreateInfo: *const FramebufferCreateInfo, pAllocator: ?*const AllocationCallbacks, pFramebuffer: *Framebuffer) Result;
pub fn CreateFramebuffer(device: Device, pCreateInfo: *const FramebufferCreateInfo, pAllocator: ?*const AllocationCallbacks) !Framebuffer {
	var buffer: Framebuffer = null;
	const result = vkCreateFramebuffer(device, pCreateInfo, pAllocator, &buffer);
	if (result == .SUCCESS) return buffer;
	try mapError(result);
}

pub extern fn vkDestroyFramebuffer(device: Device, framebuffer: Framebuffer, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyFramebuffer = vkDestroyFramebuffer;

pub extern fn vkCreateRenderPass(device: Device, pCreateInfo: *const RenderPassCreateInfo, pAllocator: ?*const AllocationCallbacks, pRenderPass: *RenderPass) Result;
pub fn CreateRenderPass(device: Device, pCreateInfo: *const RenderPassCreateInfo, pAllocator: ?*const AllocationCallbacks) !RenderPass {
	var pass: RenderPass = null;
	const result = vkCreateRenderPass(device, pCreateInfo, pAllocator, &pass);
	if (result == .SUCCESS) return pass;
	try mapError(result);
}

pub extern fn vkDestroyRenderPass(device: Device, renderPass: RenderPass, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyRenderPass = vkDestroyRenderPass;

pub extern fn vkGetRenderAreaGranularity(device: Device, renderPass: RenderPass, pGranularity: *Extent2D) void;
pub fn GetRenderAreaGranularity(device: Device, renderPass: RenderPass) Extent2D {
	var extent: Extent2D = undefined;
	vkGetRenderAreaGranularity(device, renderPass, &extent);
	return extent;
}

pub extern fn vkCreateCommandPool(device: Device, pCreateInfo: *const CommandPoolCreateInfo, pAllocator: ?*const AllocationCallbacks, pCommandPool: *CommandPool) Result;
pub fn CreateCommandPool(device: Device, pCreateInfo: *const CommandPoolCreateInfo, pAllocator: ?*const AllocationCallbacks) !CommandPool {
	var pool: CommandPool = null;
	const result = vkCreateCommandPool(device, pCreateInfo, pAllocator, &pool);
	if (result == .SUCCESS) return pool;
	try mapError(pool);
}

pub extern fn vkDestroyCommandPool(device: Device, commandPool: CommandPool, pAllocator: ?*const AllocationCallbacks) void;
pub const DestroyCommandPool = vkDestroyCommandPool;

pub extern fn vkResetCommandPool(device: Device, commandPool: CommandPool, flags: CommandPoolResetFlags) Result;
pub fn ResetCommandPool(device: Device, commandPool: CommandPool, flags: CommandPoolResetFlags) !void {
	const result = vkResetCommandPool(device, commandPool, flags);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkAllocateCommandBuffers(device: Device, pAllocateInfo: *const CommandBufferAllocateInfo, pCommandBuffers: ?[*]CommandBuffer) Result;
pub fn AllocateCommandBuffers(device: Device, pAllocateInfo: *const CommandBufferAllocateInfo, commandBuffers: []CommandBuffer) !void {
	std.debug.assert(commandBuffers.len >= pAllocateInfo.commandBufferCount);
	const result = vkAllocateCommandBuffers(device, pAllocateInfo, commandBuffers.ptr);
	if (result == .SUCCESS) return;
	try mapError(result);
}
pub fn AllocateCommandBuffer(device: Device, pAllocateInfo: *const CommandBufferAllocateInfo) !CommandBuffer {
	std.debug.assert(pAllocateInfo.commandBufferCount == 1);
	var buffers = [_]CommandBuffer{ null };
	const result = vkAllocateCommandBuffers(device, pAllocateInfo, &buffers);
	if (result == .SUCCESS) return buffers[0];
	try mapError(result);
}

pub extern fn vkFreeCommandBuffers(device: Device, commandPool: CommandPool, commandBufferCount: u32, pCommandBuffers: ?[*]const CommandBuffer) void;
pub const FreeCommandBuffers(device: Device, commandPool: CommandPool, commandBuffers: []CommandBuffer) void {
	vkFreeCommandBuffers(device, commandPool, @intCast(u32, commandBuffers.len), commandBuffers.ptr);
}



// ------------------------------------------- Functions: Command Buffer Writing ------------------------------------

pub extern fn vkBeginCommandBuffer(commandBuffer: CommandBuffer, pBeginInfo: *const CommandBufferBeginInfo) Result;
pub fn BeginCommandBuffer(commandBuffer: CommandBuffer, pBeginInfo: *const CommandBufferBeginInfo) !void {
	const result = vkBeginCommandBuffer(commandBuffer, pBeginInfo);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkEndCommandBuffer(commandBuffer: CommandBuffer) Result;
pub fn EndCommandBuffer(commandBuffer: CommandBuffer) !void {
	const result = vkEndCommandBuffer(commandBuffer);
	if (result == .SUCCESS) return;
	try mapError(result);
}

pub extern fn vkResetCommandBuffer(commandBuffer: CommandBuffer, flags: CommandBufferResetFlags) Result;
pub const ResetCommandBuffer = vkResetCommandBuffer;

pub extern fn vkCmdBindPipeline(commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, pipeline: Pipeline) void;
pub const CmdBindPipeline = vkCmdBindPipeline;

pub extern fn vkCmdSetViewport(commandBuffer: CommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: ?[*]const Viewport) void;
pub fn CmdSetViewports(commandBuffer: CommandBuffer, firstViewport: u32, newViewports: []const Viewport) void {
	vkCmdSetViewport(commandBuffer, firstViewport, @intCast(u32, newViewports.len), newViewports.ptr);
}
pub fn CmdSetViewport(commandBuffer: CommandBuffer, firstViewport: u32, newViewport: Viewport) void {
	vkCmdSetViewport(commandBuffer, firstViewport, 1, @ptrCast([*]const Viewport, &newViewport));
}

pub extern fn vkCmdSetScissor(commandBuffer: CommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: ?[*]const Rect2D) void;
pub fn CmdSetScissors(commandBuffer: CommandBuffer, firstScissor: u32, newScissors: []const Rect2D) void {
	vkCmdSetScissor(commandBuffer, firstScissor, @intCast(u32, newScissors.len), newScissors.ptr);
}
pub fn CmdSetScissor(commandBuffer: CommandBuffer, firstScissor: u32, newScissor: Rect2D) void {
	vkCmdSetScissor(commandBuffer, firstScissor, 1, @ptrCast([*]const Rect2D, &newScissor));
}

pub extern fn vkCmdSetLineWidth(commandBuffer: CommandBuffer, lineWidth: f32) void;
pub const CmdSetLineWidth = vkCmdSetLineWidth;

pub extern fn vkCmdSetDepthBias(commandBuffer: CommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32) void;
pub const CmdSetDepthBias = vkCmdSetDepthBias;

pub extern fn vkCmdSetBlendConstants(commandBuffer: CommandBuffer, blendConstants: ?[*]const f32) void;
pub fn CmdSetBlendConstants(commandBuffer: CommandBuffer, blendConstants: *[4]const f32) void {
	vkCmdSetBlendConstants(commandBuffer, @ptrCast([*]const f32, blendConstants);
}

pub extern fn vkCmdSetDepthBounds(commandBuffer: CommandBuffer, minDepthBounds: f32, maxDepthBounds: f32) void;
pub const CmdSetDepthBounds = vkCmdSetDepthBounds;

pub extern fn vkCmdSetStencilCompareMask(commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, compareMask: u32) void;
pub const CmdSetStencilCompareMask = vkCmdSetStencilCompareMask;

pub extern fn vkCmdSetStencilWriteMask(commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, writeMask: u32) void;
pub const CmdSetStencilWriteMask = vkCmdSetStencilWriteMask;

pub extern fn vkCmdSetStencilReference(commandBuffer: CommandBuffer, faceMask: StencilFaceFlags, reference: u32) void;
pub const CmdSetStencilReference = vkCmdSetStencilReference;

pub extern fn vkCmdBindDescriptorSets(commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: ?[*]const DescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: ?[*]const u32) void;
pub fn CmdBindDescriptorSets(commandBuffer: CommandBuffer, pipelineBindPoint: PipelineBindPoint, layout: PipelineLayout, firstSet: u32, descriptorSets: []const DescriptorSet, dynamicOffsets: []const u32) void {
	vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, @intCast(u32, descriptorSets.len), descriptorSets.ptr, @intCast(u32, dynamicOffsets.len), dynamicOffsets.ptr);
}

pub extern fn vkCmdBindIndexBuffer(commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, indexType: IndexType) void;
pub const CmdBindIndexBuffer = vkCmdBindIndexBuffer;

pub extern fn vkCmdBindVertexBuffers(commandBuffer: CommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: ?[*]const Buffer, pOffsets: ?[*]const DeviceSize) void;
pub fn CmdBindVertexBuffers(commandBuffer: CommandBuffer, firstBinding: u32, buffers: []const Buffer, offsets: []const DeviceSize) void {
	std.debug.assert(offsets.len >= buffers.len);
	vkCmdBindVertexBuffers(commandBuffer, firstBinding, @intCast(u32, buffers.len), buffers.ptr, offsets.ptr);
}

pub extern fn vkCmdDraw(commandBuffer: CommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) void;
pub const CmdDraw = vkCmdDraw;

pub extern fn vkCmdDrawIndexed(commandBuffer: CommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: i32, firstInstance: u32) void;
pub const CmdDrawIndexed = vkCmdDrawIndexed;

pub extern fn vkCmdDrawIndirect(commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32) void;
pub const CmdDrawIndirect = vkCmdDrawIndirect;

pub extern fn vkCmdDrawIndexedIndirect(commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize, drawCount: u32, stride: u32) void;
pub const CmdDrawIndexedIndirect = vkCmdDrawIndexedIndirect;

pub extern fn vkCmdDispatch(commandBuffer: CommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) void;
pub const CmdDispatch = vkCmdDispatch;

pub extern fn vkCmdDispatchIndirect(commandBuffer: CommandBuffer, buffer: Buffer, offset: DeviceSize) void;
pub const CmdDispatchIndirect = vkCmdDispatchIndirect;

pub extern fn vkCmdCopyBuffer(commandBuffer: CommandBuffer, srcBuffer: Buffer, dstBuffer: Buffer, regionCount: u32, pRegions: ?[*]const BufferCopy) void;
pub fn CmdCopyBuffer(commandBuffer: CommandBuffer, srcBuffer: Buffer, dstBuffer: Buffer, regions: []const BufferCopy) void {
	vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, @intCast(u32, regions.len), regions.ptr);
}

pub extern fn vkCmdCopyImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: ?[*]const ImageCopy) void;
pub fn CmdCopyImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regions: []const ImageCopy) void {
	vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, @intCast(u32, regions.len), regions.ptr);
}

pub extern fn vkCmdBlitImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: ?[*]const ImageBlit, filter: Filter) void;
pub fn CmdBlitImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regions: []const ImageBlit, filter: Filter) void {
	vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, @intCast(u32, regions.len), regions.ptr, filter);
}

pub extern fn vkCmdCopyBufferToImage(commandBuffer: CommandBuffer, srcBuffer: Buffer, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: ?[*]const BufferImageCopy) void;
pub fn CmdCopyBufferToImage(commandBuffer: CommandBuffer, srcBuffer: Buffer, dstImage: Image, dstImageLayout: ImageLayout, regions: []const BufferImageCopy) void {
	vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, @intCast(u32, regions.len), regions.ptr);
}

pub extern fn vkCmdCopyImageToBuffer(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstBuffer: Buffer, regionCount: u32, pRegions: ?[*]const BufferImageCopy) void;
pub fn CmdCopyImageToBuffer(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstBuffer: Buffer, regions: []const BufferImageCopy) void {
	vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, @intCast(u32, regions.len), regions.ptr);
}

pub extern fn vkCmdUpdateBuffer(commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, dataSize: DeviceSize, pData: ?*const c_void) void;
pub fn CmdUpdateBuffer(comptime DataType: type, commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, data: []DataType) void {
	vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, data.len * @sizeOf(DataType), data.ptr);
}

pub extern fn vkCmdFillBuffer(commandBuffer: CommandBuffer, dstBuffer: Buffer, dstOffset: DeviceSize, size: DeviceSize, data: u32) void;
pub const CmdFillBuffer = vkCmdFillBuffer;

pub extern fn vkCmdClearColorImage(commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pColor: *const ClearColorValue, rangeCount: u32, pRanges: ?[*]const ImageSubresourceRange) void;
pub const CmdClearColorImage(commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pColor: *const ClearColorValue, ranges: []const ImageSubresourceRange) void {
	vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, @intCast(u32, ranges.len), ranges.ptr);
}

pub extern fn vkCmdClearDepthStencilImage(commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pDepthStencil: *const ClearDepthStencilValue, rangeCount: u32, pRanges: ?[*]const ImageSubresourceRange) void;
pub fn CmdClearDepthStencilImage(commandBuffer: CommandBuffer, image: Image, imageLayout: ImageLayout, pDepthStencil: *const ClearDepthStencilValue, ranges: []const ImageSubresourceRange) void {
	vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, @intCast(u32, ranges.len), ranges.ptr);
}

pub extern fn vkCmdClearAttachments(commandBuffer: CommandBuffer, attachmentCount: u32, pAttachments: ?[*]const ClearAttachment, rectCount: u32, pRects: ?[*]const ClearRect) void;
pub fn CmdClearAttachments(commandBuffer: CommandBuffer, attachments: []const ClearAttachment, rects: []const ClearRect) void {
	vkCmdClearAttachments(commandBuffer, @intCast(u32, attachments.len), attachments.ptr, @intCast(u32, rects.len), rects.ptr);
}

pub extern fn vkCmdResolveImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regionCount: u32, pRegions: ?[*]const ImageResolve) void;
pub fn CmdResolveImage(commandBuffer: CommandBuffer, srcImage: Image, srcImageLayout: ImageLayout, dstImage: Image, dstImageLayout: ImageLayout, regions: []const ImageResolve) void {
	vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, @intCast(u32, regions.len), regions.ptr);
}

pub extern fn vkCmdSetEvent(commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags) void;
pub const CmdSetEvent = vkCmdSetEvent;

pub extern fn vkCmdResetEvent(commandBuffer: CommandBuffer, event: Event, stageMask: PipelineStageFlags) void;
pub const CmdResetEvent = vkCmdResetEvent;

pub extern fn vkCmdWaitEvents(commandBuffer: CommandBuffer, eventCount: u32, pEvents: ?[*]const Event, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: ?[*]const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: ?[*]const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: ?[*]const ImageMemoryBarrier) void;
pub fn CmdWaitEvents(commandBuffer: CommandBuffer, events: []const Event, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, memoryBarriers: []const MemoryBarrier, bufferMemoryBarriers: []const BufferMemoryBarrier, imageMemoryBarriers: []const ImageMemoryBarrier) void {
	vkCmdWaitEvents(commandBuffer, @intCast(u32, events.len), events.ptr, srcStageMask, dstStageMask, @intCast(u32, memoryBarriers.len), memoryBarriers.ptr, @intCast(u32, bufferMemoryBarriers.len), bufferMemoryBarriers.ptr, @intCast(u32, imageMemoryBarriers.len), imageMemoryBarriers.ptr);
}

pub extern fn vkCmdPipelineBarrier(commandBuffer: CommandBuffer, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, dependencyFlags: DependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: ?[*]const MemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: ?[*]const BufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: ?[*]const ImageMemoryBarrier) void;
pub fn CmdPipelineBarrier(commandBuffer: CommandBuffer, srcStageMask: PipelineStageFlags, dstStageMask: PipelineStageFlags, memoryBarriers: []const MemoryBarrier, bufferMemoryBarriers: []const BufferMemoryBarrier, imageMemoryBarriers: []const ImageMemoryBarrier) void {
	vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, @intCast(u32, memoryBarriers.len), memoryBarriers.ptr, @intCast(u32, bufferMemoryBarriers.len), bufferMemoryBarriers.ptr, @intCast(u32, imageMemoryBarriers.len), imageMemoryBarriers.ptr);
}

pub extern fn vkCmdBeginQuery(commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32, flags: QueryControlFlags) void;
pub const CmdBeginQuery = vkCmdBeginQuery;

pub extern fn vkCmdEndQuery(commandBuffer: CommandBuffer, queryPool: QueryPool, query: u32) void;
pub const CmdEndQuery = vkCmdEndQuery;

pub extern fn vkCmdResetQueryPool(commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32) void;
pub const CmdResetQueryPool = vkCmdResetQueryPool;

pub extern fn vkCmdWriteTimestamp(commandBuffer: CommandBuffer, pipelineStage: PipelineStageFlags, queryPool: QueryPool, query: u32) void;
pub const CmdWriteTimestamp = vkCmdWriteTimestamp;

pub extern fn vkCmdCopyQueryPoolResults(commandBuffer: CommandBuffer, queryPool: QueryPool, firstQuery: u32, queryCount: u32, dstBuffer: Buffer, dstOffset: DeviceSize, stride: DeviceSize, flags: QueryResultFlags) void;
pub const CmdCopyQueryPoolResults = vkCmdCopyQueryPoolResults;

pub extern fn vkCmdPushConstants(commandBuffer: CommandBuffer, layout: PipelineLayout, stageFlags: ShaderStageFlags, offset: u32, size: u32, pValues: ?*const c_void) void;
// @TODO: Figure out a good binding

pub extern fn vkCmdBeginRenderPass(commandBuffer: CommandBuffer, pRenderPassBegin: *const RenderPassBeginInfo, contents: SubpassContents) void;
pub const CmdBeginRenderPass = vkCmdBeginRenderPass;

pub extern fn vkCmdNextSubpass(commandBuffer: CommandBuffer, contents: SubpassContents) void;
pub const CmdNextSubpass = vkCmdNextSubpass;

pub extern fn vkCmdEndRenderPass(commandBuffer: CommandBuffer) void;
pub const CmdEndRenderPass = vkCmdEndRenderPass;

pub extern fn vkCmdExecuteCommands(commandBuffer: CommandBuffer, commandBufferCount: u32, pCommandBuffers: ?[*]const CommandBuffer) void;
pub fn CmdExecuteCommands(commandBuffer: CommandBuffer, commandBuffers: []const CommandBuffer) void {
	vkCmdExecuteCommands(commandBuffer, @intCast(u32, commandBuffers.len), commandBuffers.ptr);
}


